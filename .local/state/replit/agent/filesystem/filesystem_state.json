{"file_contents":{"replit.md":{"content":"# Анализатор управления ресурсами\n\n## Overview\nThis desktop application, built with Streamlit, analyzes Microsoft Project plan files. It parses MS Project XML files to identify workload imbalances among resources, visualizes allocation patterns with color-coded status indicators, and provides actionable recommendations for optimization. Users can filter resources, view detailed task breakdowns, and export analysis results in CSV or PDF format. The project aims to provide a quick prototyping interface focused on data analysis without complex frontend development, offering a Python-native approach to building interactive web applications for data visualization.\n\n## Recent Changes (November 1, 2025)\n\n**Latest Fix (.exe Build - PackageNotFoundError & Compilation Errors - November 1, 2025):**\n- **Problem Solved**: Fixed critical `importlib.metadata.PackageNotFoundError` when running MSProjectAnalyzer.exe\n- **Root Cause**: PyInstaller wasn't including package metadata (version info) that Streamlit checks at runtime\n- **Solution Implemented**:\n  - Updated `app.spec`: Added `copy_metadata()` calls for all libraries (streamlit, pandas, plotly, altair, lxml, reportlab, openpyxl, python-dateutil, pyarrow, click, validators, watchdog, tornado)\n  - Updated `build_exe.bat`: \n    - Added `--only-binary :all:` for pandas and pyarrow installation (prevents Windows compilation errors)\n    - Separated dependency installation: first pip/wheel/setuptools upgrade, then pandas/pyarrow binaries, then remaining packages\n    - Added clear error messages and 64-bit Python verification hints\n  - Updated `BUILD_INSTRUCTIONS.md`: Added troubleshooting sections for:\n    - PackageNotFoundError with clear explanation and rebuild steps\n    - Windows compilation errors (pandas/pyarrow) with --only-binary solutions\n    - 64-bit Python verification and Microsoft C++ Build Tools guidance\n- **Testing**: Architect-reviewed, user successfully built .exe after fixes\n- **Files Modified**: app.spec (copy_metadata), build_exe.bat (--only-binary installation), BUILD_INSTRUCTIONS.md (troubleshooting)\n\n**Previous Enhancement (Display Mode Switcher - October 31, 2025):**\n- **Display Mode Toggle**: Added switchable display mode for workload visualization with two options:\n  - **В процентах (Percentage mode)**: Default mode showing workload as percentage of capacity\n    - Analysis table column: \"Нагрузка %\" with values like \"85.5%\"\n    - Chart Y-axis: \"Процент нагрузки (%)\"\n    - Threshold lines: 100% (overloaded) and 70% (underutilized)\n  - **В часах (Hours mode)**: Shows workload in absolute hours\n    - Analysis table column: \"Загрузка (часы)\" with values like \"68.4 ч.\"\n    - Chart Y-axis: \"Загрузка (часы)\"\n    - Threshold lines: calculated based on average capacity per resource\n- **Implementation Details**:\n  - Radio button control in sidebar: \"Отображение загрузки\"\n  - Mode stored in `st.session_state.display_mode` ('percentage' or 'hours')\n  - Triggers automatic page reload (st.rerun) with full state persistence\n  - Affects all visualization components: analysis table, workload distribution chart, weekly timeline chart\n- **Export Support**: CSV and PDF export functions updated to handle both display modes\n  - Status determination based on percentage calculation regardless of display mode\n  - Column headers and values adapt to selected mode\n- **Testing**: E2E verified both modes work correctly with seamless switching across all components\n\n**Previous Enhancements (Resource Groups, Period Analytics & Actual Hours):**\n- **Resource Groups Management**: Added complete workflow for managing custom resource groups:\n  - Create groups with custom names and selected resources\n  - Save groups in session state (persist during session)\n  - Apply groups via explicit button with UI refresh (st.rerun)\n  - Delete groups with automatic cleanup of applied state\n  - Expander-based UI for group creation and management\n- **Period Analysis Panel**: Added control panel displaying:\n  - Selected date range (formatted as DD.MM.YYYY - DD.MM.YYYY)\n  - Business days count (excluding weekends: Saturday, Sunday)\n  - Work capacity per person (business_days × 8 hours)\n  - Implemented `calculate_business_days()` and `calculate_work_capacity()` helper functions\n- **Actual Working Hours**: New column \"Рабочие часы за период\" in analysis table:\n  - Calculates actual hours for each resource within selected date range\n  - Uses proportional allocation for tasks spanning multiple periods\n  - Implemented `calculate_actual_hours_per_resource()` function\n- **Enhanced CSV/PDF Export**: Exports now include:\n  - Period information header (dates, business days, capacity)\n  - New \"Рабочие часы за период\" / \"Часы за период\" column in resource tables\n  - Updated export function signatures with period parameters\n- **Bug Fixes**: \n  - Fixed `KeyError: 'start_date'` in `calculate_actual_hours_per_resource`: now uses task.get('start')/task.get('finish') and parser.assignments\n  - Fixed group application flow: added \"Применить группу\" button with proper st.rerun() behavior\n\n**Previous Enhancements (Smart Default Dates & Resource Filtering):**\n- **Default Date Range Logic**: Changed initialization from full project range to current week context:\n  - Start: current date - 7 days, rounded to Monday (weekday=0)\n  - End: current date + 14 days, rounded to Friday (weekday=4)\n  - Dates are clamped within project bounds to prevent `StreamlitAPIException`\n  - Provides focused 3-week analysis window by default\n- **Resource Filter Applied Globally**: selected_resources filter now affects ALL UI sections:\n  - Task details section (uses filtered display_data)\n  - Recommendations (filtered_analysis created with resource filtering)\n  - Workload distribution chart (uses filtered display_data)\n  - Optimization suggestions (selected_resources passed to optimize_with_task_shifting)\n  - Weekly timeline visualization (timeline_data filtered by keys)\n  - Interactive specialist replacement (uses filtered_analysis)\n- **Bug Fix**: Fixed date clamp logic to prevent defaults outside project_start...project_end bounds\n\n**Previous Bug Fixes (Export Functionality):**\n- Fixed `UnicodeEncodeError` in CSV export: Added `remove_emojis()` function to strip emoji symbols (🔴, 🟢) before cp1251 encoding, ensuring Excel compatibility\n- Fixed `KeyError: 'task'` in export functions: Updated CSV/PDF exporters to use correct optimization_results structure (`task_name`, `shift_days`, `improvement`, `reason`, `priority` instead of deprecated `task`, `action`, `details`)\n- Enhanced export data completeness: CSV/PDF now include 4 sections (summary, task details, weekly timeline, optimization suggestions) with proper field mapping\n\n**Previous Critical Bug Fixes:**\n- Fixed `AttributeError: 'Figure' object has no attribute 'update_xaxis'` - replaced with correct Plotly methods: `update_xaxes()` and `update_yaxes()`\n- Optimized task shifting algorithm: weeks_with_dates construction moved to resource level (instead of repeating for each task)\n- Improved target week determination logic: now finds ALL overlapping weeks, selects the main one with the largest task proportion\n- Added real hours calculation instead of percentages only: hours_removed_from_source and hours_added_to_target\n- Fixed date range filtering bug: `weeks_with_dates` in `optimize_with_task_shifting` now constructed from filtered `date_range` for consistency with timeline_data\n\n**End-to-End Testing:**\n- All core features working correctly\n- Verified: file upload, smart default dates, resource filtering across all sections (task details, recommendations, charts, optimization, timeline, interactive replacement)\n- Previous verifications: analysis, optimization, visualization, CSV/PDF export with emoji sanitization and correct optimization schema\n\n## User Preferences\nПредпочитаемый стиль коммуникации: Простой, повседневный язык на русском.\n\n## System Architecture\n\n### UI/UX Decisions\nThe application uses Streamlit for rapid prototyping and interactive data visualization. Plotly is utilized for interactive, professional-grade charts, enabling rich interactivity like hovering, zooming, and panning. \n\n**Design System**: The application uses Material Design 3 (MD3) as its single design system:\n- **Material Design 3**: Google's MD3 design system with elevated cards, rounded corners, modern typography, and a purple-blue color palette generated from seed color #0078D4\n  - Colors: Primary #005EB0, Error #BA1A1A, Tertiary #6D5677, Surface #FEF7FF\n  - Modular components defined in `md3_components.py`\n  - Elevated metric cards, alternating row styles, and hover effects\n  - Red/Yellow/Green color-coding system for workload status (overloaded/underutilized/optimal)\n\n**Display Modes**: Users can switch between two display modes for workload visualization:\n- **В процентах (Percentage)**: Shows workload as percentage of capacity (default)\n- **В часах (Hours)**: Shows workload in absolute hours\n- Mode selection stored in `st.session_state.display_mode` and triggers automatic page reload with full state preservation\n\n### Technical Implementations\nThe backend processes MS Project XML files using `lxml` for robust parsing, handling large files efficiently. Data manipulation and complex resource allocation calculations are performed using Pandas DataFrames.\n\n### Feature Specifications\n- **Workload Calculation Logic**: Resources are categorized as Overloaded (>100% capacity - Red), Optimal (70-100% capacity - Green), or Underutilized (<70% capacity - Yellow) based on actual project timelines versus resource capacity.\n- **Recommendation Engine**: Provides actionable suggestions for rebalancing workloads, prioritizing resources based on their overload percentage (High: >120%, Medium: 100-120%, Low: optimizing underutilized resources).\n- **Intelligent Optimization**:\n    - Calculates weekly resource loading, identifies peaks and troughs, and caches tasks for performance.\n    - Implements a task shifting algorithm to automatically suggest optimal task shifts (1-30 days) for overloaded weeks, considering multi-week tasks and ensuring the target week does not become overloaded.\n    - Offers interactive specialist replacement, allowing users to substitute overloaded resources with underutilized ones.\n    - Visualizes weekly loading with Plotly bar charts, showing 100% and target loading lines, and color-coded weeks (red for overloaded, green for optimal, yellow for underutilized).\n- **Report Generation**: Exports professional PDF reports using ReportLab with custom styling and CSV exports via Pandas for raw data analysis.\n- **State Management**: Utilizes `st.session_state` to preserve parsed data, user selections, and analysis results across interactions.\n\n### System Design Choices\nThe application is designed to be highly interactive and data-driven, leveraging Python's strengths in data processing and web application development. The choice of Streamlit and Plotly reflects a priority for quick development and rich interactive visualization.\n\n## External Dependencies\n\n### Core Libraries\n- **Streamlit**: Web framework for interactive applications.\n- **Pandas**: For tabular data manipulation and analysis.\n- **lxml**: High-performance XML parser, specifically for Microsoft Project XML files.\n- **Plotly**: For interactive charting and data visualization.\n- **ReportLab**: For generating PDF documents.\n\n### File Format Support\n- **Microsoft Project XML**: Supports `.xml` and `.mspdi` file formats. `.mpp` files must be converted to XML from MS Project.","size_bytes":11809},"README.md":{"content":"# Анализатор управления ресурсами\n\nПрофессиональное настольное приложение для анализа файлов планов Microsoft Project с целью выявления дисбаланса рабочей нагрузки и предоставления рекомендаций по оптимизации.\n\n## Возможности\n\n- **Поддержка файлов MS Project**: Загрузка и парсинг XML-файлов Microsoft Project (.xml, .mspdi)\n- **Интеллектуальный расчёт рабочей нагрузки**: Анализ распределения ресурсов на основе фактических сроков проекта и мощности ресурсов\n- **Поиск персонала**: Фильтрация и поиск задач по именам и фамилиям ресурсов\n- **Визуальный анализ**: Цветные индикаторы статуса для быстрого выявления проблем с ресурсами\n  - 🔴 Красный: Перегружен (>100% мощности)\n  - 🟢 Зелёный: Оптимально (70-100% мощности)\n  - 🟡 Жёлтый: Недоиспользуется (<70% мощности)\n- **Умные рекомендации**: Практические предложения по балансировке рабочей нагрузки\n- **Варианты экспорта**: Скачивание анализа в формате CSV или PDF\n\n## Как использовать\n\n### 1. Подготовка файла MS Project\n\nЕсли у вас есть файл .mpp, конвертируйте его в формат XML:\n1. Откройте ваш проект в Microsoft Project\n2. Перейдите в **Файл → Сохранить как**\n3. Выберите **Формат XML (*.xml)** в качестве типа файла\n4. Сохраните файл\n\n### 2. Загрузка и анализ\n\n1. Нажмите \"Выберите файл\" на боковой панели\n2. Выберите ваш XML-файл MS Project\n3. Нажмите \"Анализировать файл\" для анализа данных\n4. Просмотрите панель анализа рабочей нагрузки\n\n### 3. Фильтрация и поиск\n\n- Используйте поле поиска для фильтрации ресурсов по имени или фамилии\n- Выберите конкретные ресурсы с помощью выпадающего списка множественного выбора\n- Разверните отдельные ресурсы для просмотра детальной разбивки задач\n\n### 4. Просмотр рекомендаций\n\nСистема предоставляет приоритизированные рекомендации:\n- **Высокий приоритет**: Ресурсы с нагрузкой более 120%\n- **Средний приоритет**: Ресурсы с нагрузкой 100-120%\n- **Низкий приоритет**: Предложения по оптимизации недоиспользуемых ресурсов\n\n### 5. Экспорт результатов\n\nСкачайте ваш анализ в виде:\n- **CSV**: Для дальнейшего анализа в Excel или других инструментах\n- **PDF**: Профессиональный отчёт для презентаций\n\n## Расчёт рабочей нагрузки\n\nПриложение рассчитывает процент рабочей нагрузки на основе:\n\n- **Длительности проекта**: Автоматически определяется из дат начала/окончания задач\n- **Мощности ресурса**: На основе MaxUnits и стандартной 40-часовой рабочей недели (5 дней × 8 часов)\n- **Назначений задач**: Общее количество часов, выделенных каждому ресурсу\n\n**Модель мощности**:\n- Календарные дни конвертируются в рабочие дни с использованием соотношения 5/7 (5-дневная рабочая неделя)\n- Каждый рабочий день предоставляет 8 часов рабочей мощности (соответствует P1D = 8 часов в MS Project)\n- Мощность ресурса = Доступные рабочие часы × MaxUnits\n\n**Формула**: `Нагрузка % = (Общее количество назначенных часов / Мощность) × 100`\n\n**Примеры** (для MaxUnits = 1.0):\n- 1 календарный день → 0.71 рабочих дней → 5.71 рабочих часов мощности\n- 7 календарных дней → 5 рабочих дней → 40 рабочих часов мощности\n- 28 календарных дней → 20 рабочих дней → 160 рабочих часов мощности\n\n## Цветовая схема\n\nВ соответствии с руководством по дизайну Microsoft Project:\n- Основной синий: #0078D4\n- Зелёный успеха: #107C10\n- Красный предупреждения: #FF4B4B\n- Серый фона: #F3F2F1\n- Угольный текст: #323130\n\n## Образец данных\n\nОбразец файла проекта (`sample_project.xml`) включён для тестирования. Он демонстрирует:\n- 5 ресурсов с различной рабочей нагрузкой\n- 8 задач с разной длительностью\n- Назначения ресурсов, показывающие сценарии перегрузки и недоиспользования\n\n## Технические детали\n\n- Построен на Streamlit для интерактивного веб-интерфейса\n- Использует lxml для надёжного парсинга XML\n- Plotly для интерактивных визуализаций\n- ReportLab для генерации PDF\n- Pandas для обработки данных\n\n## Поддержка\n\nПри проблемах с:\n- **Парсингом файлов**: Убедитесь, что ваш XML-файл правильно отформатирован как экспорт MS Project\n- **Расчётами дат**: Проверьте, что задачи имеют корректные даты начала и окончания\n- **Отсутствующими ресурсами**: Проверьте, что ресурсы правильно назначены в исходном проекте\n","size_bytes":6940},"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport io\nfrom lxml import etree\nfrom reportlab.lib import colors\nfrom reportlab.lib.pagesizes import letter, A4\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.units import inch\nfrom reportlab.pdfbase import pdfmetrics\nfrom reportlab.pdfbase.ttfonts import TTFont\n\n# Импорт MD3 компонентов\nfrom md3_components import get_md3_css, md3_info_panel, get_md3_table_style, get_md3_chart_colors\n\n# Конфигурация страницы\nst.set_page_config(\n    page_title=\"Анализатор управления ресурсами\",\n    page_icon=\"📊\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Применение MD3 дизайна\nst.markdown(get_md3_css(), unsafe_allow_html=True)\n\n# MS Project XML Parser\nclass MSProjectParser:\n    \"\"\"Парсер для XML-файлов MS Project (.xml, .mspdi)\"\"\"\n    \n    def __init__(self, file_content):\n        self.file_content = file_content\n        self.tasks = []\n        self.resources = []\n        self.assignments = []\n    \n    @staticmethod\n    def clean_xml_content(xml_bytes):\n        \"\"\"\n        Удаляет недопустимые символы из XML-контента.\n        XML 1.0 допускает только определённые символы:\n        - 0x09 (tab), 0x0A (LF), 0x0D (CR)\n        - 0x20-0xD7FF, 0xE000-0xFFFD, 0x10000-0x10FFFF\n        \"\"\"\n        # Декодируем в строку\n        try:\n            xml_str = xml_bytes.decode('utf-8')\n        except:\n            xml_str = xml_bytes.decode('utf-8', errors='ignore')\n        \n        # Функция для проверки допустимости символа\n        def is_valid_xml_char(c):\n            codepoint = ord(c)\n            return (\n                codepoint == 0x09 or\n                codepoint == 0x0A or\n                codepoint == 0x0D or\n                (0x20 <= codepoint <= 0xD7FF) or\n                (0xE000 <= codepoint <= 0xFFFD) or\n                (0x10000 <= codepoint <= 0x10FFFF)\n            )\n        \n        # Фильтруем недопустимые символы\n        cleaned_str = ''.join(c for c in xml_str if is_valid_xml_char(c))\n        \n        # Возвращаем обратно в байты\n        return cleaned_str.encode('utf-8')\n        \n    def parse(self):\n        \"\"\"Парсинг XML-файла MS Project\"\"\"\n        try:\n            # Очищаем XML от недопустимых символов\n            cleaned_content = self.clean_xml_content(self.file_content)\n            \n            tree = etree.parse(io.BytesIO(cleaned_content))\n            root = tree.getroot()\n            \n            # Получение namespace\n            namespace = {'ns': root.nsmap[None]} if None in root.nsmap else {}\n            \n            # Парсинг ресурсов\n            self.resources = self._parse_resources(root, namespace)\n            \n            # Парсинг задач\n            self.tasks = self._parse_tasks(root, namespace)\n            \n            # Парсинг назначений\n            self.assignments = self._parse_assignments(root, namespace)\n            \n            return True\n        except Exception as e:\n            st.error(f\"Ошибка при парсинге файла MS Project: {str(e)}\")\n            return False\n    \n    def _parse_resources(self, root, namespace):\n        \"\"\"Парсинг информации о ресурсах\"\"\"\n        resources = []\n        resource_elements = root.findall('.//ns:Resource', namespace) if namespace else root.findall('.//Resource')\n        \n        for resource in resource_elements:\n            resource_id = self._get_text(resource, 'ns:UID' if namespace else 'UID', namespace)\n            name = self._get_text(resource, 'ns:Name' if namespace else 'Name', namespace)\n            \n            if resource_id and name:\n                resources.append({\n                    'id': resource_id,\n                    'name': name,\n                    'max_units': self._get_text(resource, 'ns:MaxUnits' if namespace else 'MaxUnits', namespace, default='1.0')\n                })\n        \n        return resources\n    \n    def _parse_tasks(self, root, namespace):\n        \"\"\"Parse task information\"\"\"\n        tasks = []\n        task_elements = root.findall('.//ns:Task', namespace) if namespace else root.findall('.//Task')\n        \n        for task in task_elements:\n            task_id = self._get_text(task, 'ns:UID' if namespace else 'UID', namespace)\n            name = self._get_text(task, 'ns:Name' if namespace else 'Name', namespace)\n            \n            if task_id and name:\n                tasks.append({\n                    'id': task_id,\n                    'name': name,\n                    'start': self._get_text(task, 'ns:Start' if namespace else 'Start', namespace),\n                    'finish': self._get_text(task, 'ns:Finish' if namespace else 'Finish', namespace),\n                    'duration': self._get_text(task, 'ns:Duration' if namespace else 'Duration', namespace),\n                    'work': self._get_text(task, 'ns:Work' if namespace else 'Work', namespace)\n                })\n        \n        return tasks\n    \n    def _parse_assignments(self, root, namespace):\n        \"\"\"Parse resource assignments\"\"\"\n        assignments = []\n        assignment_elements = root.findall('.//ns:Assignment', namespace) if namespace else root.findall('.//Assignment')\n        \n        for assignment in assignment_elements:\n            task_uid = self._get_text(assignment, 'ns:TaskUID' if namespace else 'TaskUID', namespace)\n            resource_uid = self._get_text(assignment, 'ns:ResourceUID' if namespace else 'ResourceUID', namespace)\n            work = self._get_text(assignment, 'ns:Work' if namespace else 'Work', namespace)\n            \n            if task_uid and resource_uid:\n                assignments.append({\n                    'task_id': task_uid,\n                    'resource_id': resource_uid,\n                    'work': work,\n                    'units': self._get_text(assignment, 'ns:Units' if namespace else 'Units', namespace, default='1.0')\n                })\n        \n        return assignments\n    \n    def _get_text(self, element, tag, namespace, default=''):\n        \"\"\"Helper to get text from XML element\"\"\"\n        try:\n            found = element.find(tag, namespace) if namespace else element.find(tag)\n            return found.text if found is not None and found.text else default\n        except:\n            return default\n    \n    def get_resource_workload_data(self, date_range_start=None, date_range_end=None):\n        \"\"\"\n        Calculate workload data for each resource.\n        \n        Args:\n            date_range_start: Начало анализируемого периода (datetime.date or None)\n            date_range_end: Конец анализируемого периода (datetime.date or None)\n        \"\"\"\n        workload_data = []\n        \n        # Calculate project timeframe for capacity calculation\n        project_start = None\n        project_end = None\n        \n        for task in self.tasks:\n            if task['start']:\n                task_start = self._parse_date(task['start'])\n                if task_start and (project_start is None or task_start < project_start):\n                    project_start = task_start\n            \n            if task['finish']:\n                task_end = self._parse_date(task['finish'])\n                if task_end and (project_end is None or task_end > project_end):\n                    project_end = task_end\n        \n        # Использовать выбранный диапазон или весь проект\n        if date_range_start and date_range_end:\n            # Конвертировать date в datetime для вычислений\n            from datetime import datetime as dt_class\n            range_start_dt = dt_class.combine(date_range_start, dt_class.min.time())\n            range_end_dt = dt_class.combine(date_range_end, dt_class.max.time())\n        else:\n            range_start_dt = project_start\n            range_end_dt = project_end\n        \n        # Calculate total available work hours for the selected range\n        # MS Project model: 1 workday (P1D) = 8 hours\n        # Default capacity for resources is 8 hours per workday\n        if range_start_dt and range_end_dt:\n            range_duration = range_end_dt - range_start_dt\n            calendar_days = range_duration.total_seconds() / (24 * 3600)\n            \n            if calendar_days <= 0:\n                # Minimum: 1 workday\n                available_work_hours_base = 8\n            else:\n                # Count workdays (approximate: 5/7 of calendar days are workdays)\n                workdays = calendar_days * (5.0 / 7.0)\n                # 8 hours per workday\n                available_work_hours_base = workdays * 8\n        else:\n            # Default: 4 weeks = 20 workdays = 160 hours\n            available_work_hours_base = 160\n        \n        for resource in self.resources:\n            # Get all assignments for this resource\n            resource_assignments = [a for a in self.assignments if a['resource_id'] == resource['id']]\n            \n            # Calculate total work hours (only within date range)\n            total_work_hours = 0\n            task_details = []\n            \n            for assignment in resource_assignments:\n                # Get task info\n                task = next((t for t in self.tasks if t['id'] == assignment['task_id']), None)\n                if task and task['start'] and task['finish']:\n                    task_start = self._parse_date(task['start'])\n                    task_end = self._parse_date(task['finish'])\n                    \n                    if task_start and task_end and range_start_dt and range_end_dt:\n                        # Проверить пересечение задачи с диапазоном\n                        overlap_days, proportion = self.compute_overlap(\n                            task_start, task_end, range_start_dt, range_end_dt\n                        )\n                        \n                        if proportion > 0:\n                            # Учитывать только часы попадающие в диапазон\n                            total_task_hours = self._parse_work_hours(assignment['work'])\n                            hours_in_range = total_task_hours * proportion\n                            total_work_hours += hours_in_range\n                            \n                            task_details.append({\n                                'task_name': task['name'],\n                                'work_hours': hours_in_range,\n                                'total_hours': total_task_hours,\n                                'proportion': proportion,\n                                'start': task.get('start', 'N/A'),\n                                'finish': task.get('finish', 'N/A')\n                            })\n                    else:\n                        # Если нет диапазона, учитывать всю задачу\n                        work_hours = self._parse_work_hours(assignment['work'])\n                        total_work_hours += work_hours\n                        task_details.append({\n                            'task_name': task['name'],\n                            'work_hours': work_hours,\n                            'start': task.get('start', 'N/A'),\n                            'finish': task.get('finish', 'N/A')\n                        })\n            \n            # Calculate capacity based on resource MaxUnits and available work hours\n            max_units = float(resource.get('max_units', 1.0))\n            # Capacity = available work hours × max_units\n            max_capacity = available_work_hours_base * max_units\n            workload_percentage = (total_work_hours / max_capacity) * 100 if max_capacity > 0 else 0\n            \n            # Calculate project weeks for display purposes\n            project_weeks = available_work_hours_base / 40\n            \n            workload_data.append({\n                'resource_name': resource['name'],\n                'total_work_hours': total_work_hours,\n                'max_capacity': max_capacity,\n                'workload_percentage': workload_percentage,\n                'task_count': len(resource_assignments),\n                'tasks': task_details,\n                'project_weeks': project_weeks\n            })\n        \n        return workload_data\n    \n    def _parse_date(self, date_string):\n        \"\"\"Parse date string to datetime object\"\"\"\n        if not date_string:\n            return None\n        \n        try:\n            # Try ISO format first\n            return datetime.fromisoformat(date_string.replace('Z', '+00:00'))\n        except:\n            try:\n                # Try common MS Project formats\n                for fmt in ['%Y-%m-%dT%H:%M:%S', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d']:\n                    try:\n                        return datetime.strptime(date_string, fmt)\n                    except:\n                        continue\n            except:\n                pass\n        \n        return None\n    \n    def _parse_work_hours(self, work_string):\n        \"\"\"Parse work hours from MS Project ISO-8601 duration format (e.g., PT8H0M0S, P2DT4H0M0S)\"\"\"\n        if not work_string:\n            return 0\n        \n        try:\n            # MS Project uses ISO-8601 duration format: P[n]DT[n]H[n]M[n]S\n            # P2DT4H30M0S = 2 days, 4 hours, 30 minutes\n            hours = 0\n            \n            if work_string.startswith('P'):\n                # Extract days (assuming 8-hour workdays)\n                if 'D' in work_string:\n                    d_start = 1  # After 'P'\n                    d_end = work_string.index('D')\n                    days = float(work_string[d_start:d_end])\n                    hours += days * 8  # 8-hour workday\n                \n                # Extract hours\n                if 'H' in work_string:\n                    # Find start position (after 'T' or 'D')\n                    if 'T' in work_string:\n                        h_start = work_string.index('T') + 1\n                    else:\n                        h_start = work_string.index('D') + 1\n                    h_end = work_string.index('H')\n                    # Extract the number between start and 'H'\n                    h_str = work_string[h_start:h_end]\n                    # Remove any non-digit characters except '.'\n                    h_str = ''.join(c for c in h_str if c.isdigit() or c == '.')\n                    if h_str:\n                        hours += float(h_str)\n                \n                # Extract minutes\n                if 'M' in work_string and 'T' in work_string:\n                    m_start = work_string.index('H') + 1 if 'H' in work_string else work_string.index('T') + 1\n                    m_end = work_string.index('M')\n                    m_str = work_string[m_start:m_end]\n                    m_str = ''.join(c for c in m_str if c.isdigit() or c == '.')\n                    if m_str:\n                        minutes = float(m_str)\n                        hours += minutes / 60\n                \n                return hours\n            else:\n                # Try to parse as number\n                return float(work_string)\n        except Exception as e:\n            # Fallback to 0 if parsing fails\n            return 0\n    \n    def get_timeline_workload(self, date_range_start=None, date_range_end=None):\n        \"\"\"\n        Рассчитать временную загрузку ресурсов по неделям.\n        \n        Args:\n            date_range_start: Начало анализируемого периода (datetime.date or None)\n            date_range_end: Конец анализируемого периода (datetime.date or None)\n        \"\"\"\n        timeline_data = {}\n        \n        # Определить временные границы проекта\n        project_start = None\n        project_end = None\n        \n        for task in self.tasks:\n            if task['start']:\n                task_start = self._parse_date(task['start'])\n                if task_start and (project_start is None or task_start < project_start):\n                    project_start = task_start\n            \n            if task['finish']:\n                task_end = self._parse_date(task['finish'])\n                if task_end and (project_end is None or task_end > project_end):\n                    project_end = task_end\n        \n        # Использовать выбранный диапазон или весь проект\n        if date_range_start and date_range_end:\n            from datetime import datetime as dt_class\n            range_start_dt = dt_class.combine(date_range_start, dt_class.min.time())\n            range_end_dt = dt_class.combine(date_range_end, dt_class.max.time())\n        else:\n            range_start_dt = project_start\n            range_end_dt = project_end\n        \n        if not range_start_dt or not range_end_dt:\n            return {}\n        \n        # Кэшировать задачи для быстрого доступа\n        task_dict = {t['id']: t for t in self.tasks}\n        \n        # Создать недельные периоды только для выбранного диапазона\n        current_date = range_start_dt\n        weeks = []\n        while current_date <= range_end_dt:\n            week_end = current_date + timedelta(days=6)\n            weeks.append({\n                'start': current_date,\n                'end': min(week_end, range_end_dt),\n                'label': f\"{current_date.strftime('%d.%m')} - {min(week_end, range_end_dt).strftime('%d.%m')}\"\n            })\n            current_date = week_end + timedelta(days=1)\n        \n        # Для каждого ресурса рассчитать загрузку по неделям\n        for resource in self.resources:\n            resource_assignments = [a for a in self.assignments if a['resource_id'] == resource['id']]\n            weekly_loads = []\n            \n            for week in weeks:\n                week_hours = 0\n                \n                for assignment in resource_assignments:\n                    task = task_dict.get(assignment['task_id'])  # Использовать кэш\n                    if task and task['start'] and task['finish']:\n                        task_start = self._parse_date(task['start'])\n                        task_end = self._parse_date(task['finish'])\n                        \n                        if task_start and task_end:\n                            # Проверить пересечение задачи с неделей\n                            overlap_start = max(task_start, week['start'])\n                            overlap_end = min(task_end, week['end'])\n                            \n                            if overlap_start <= overlap_end:\n                                # Рассчитать долю работы в этой неделе\n                                task_total_hours = self._parse_work_hours(assignment['work'])\n                                task_duration_days = (task_end - task_start).days + 1\n                                overlap_days = (overlap_end - overlap_start).days + 1\n                                \n                                if task_duration_days > 0:\n                                    proportion = overlap_days / task_duration_days\n                                    week_hours += task_total_hours * proportion\n                \n                # Ёмкость за неделю: 5 рабочих дней × 8 часов × max_units\n                max_units = float(resource.get('max_units', 1.0))\n                week_capacity = 40 * max_units\n                week_percentage = (week_hours / week_capacity) * 100 if week_capacity > 0 else 0\n                \n                weekly_loads.append({\n                    'week': week['label'],\n                    'week_start': week['start'],\n                    'week_end': week['end'],\n                    'hours': week_hours,\n                    'capacity': week_capacity,\n                    'percentage': week_percentage\n                })\n            \n            timeline_data[resource['name']] = weekly_loads\n        \n        return timeline_data\n    \n    def get_project_dates(self):\n        \"\"\"Получить минимальную и максимальную даты проекта\"\"\"\n        project_start = None\n        project_end = None\n        \n        for task in self.tasks:\n            if task['start']:\n                task_start = self._parse_date(task['start'])\n                if task_start and (project_start is None or task_start < project_start):\n                    project_start = task_start\n            \n            if task['finish']:\n                task_end = self._parse_date(task['finish'])\n                if task_end and (project_end is None or task_end > project_end):\n                    project_end = task_end\n        \n        return project_start, project_end\n    \n    @staticmethod\n    def compute_overlap(task_start, task_end, range_start, range_end):\n        \"\"\"\n        Рассчитать пересечение задачи с временным диапазоном.\n        Возвращает (overlap_days, proportion) где:\n        - overlap_days: количество дней пересечения\n        - proportion: доля задачи попадающая в диапазон (0.0-1.0)\n        \"\"\"\n        # Проверить что задача пересекается с диапазоном\n        if task_end < range_start or task_start > range_end:\n            return 0, 0.0\n        \n        # Найти пересечение\n        overlap_start = max(task_start, range_start)\n        overlap_end = min(task_end, range_end)\n        \n        # Рассчитать дни\n        overlap_days = (overlap_end - overlap_start).days + 1\n        task_total_days = (task_end - task_start).days + 1\n        \n        # Рассчитать пропорцию\n        proportion = overlap_days / task_total_days if task_total_days > 0 else 0.0\n        \n        return max(0, overlap_days), max(0.0, min(1.0, proportion))\n\n# Analysis functions\ndef analyze_workload(workload_data):\n    \"\"\"Analyze workload and categorize resources\"\"\"\n    analysis = {\n        'overloaded': [],\n        'optimal': [],\n        'underutilized': []\n    }\n    \n    for item in workload_data:\n        percentage = item['workload_percentage']\n        if percentage > 100:\n            analysis['overloaded'].append(item)\n        elif percentage >= 70:\n            analysis['optimal'].append(item)\n        else:\n            analysis['underutilized'].append(item)\n    \n    return analysis\n\ndef optimize_with_task_shifting(parser, settings, date_range_start=None, date_range_end=None, selected_resources=None):\n    \"\"\"\n    Оптимизация распределения с смещением задач во времени\n    \n    Args:\n        parser: MSProjectParser instance\n        settings: Настройки оптимизации\n            {\n                'max_shift_days': int,  # Максимальное смещение задач в днях\n                'target_load': float,   # Целевая загрузка (70-100%)\n                'mode': 'balance'       # Режим: 'balance' или 'minimize_peaks'\n            }\n        date_range_start: Начало анализируемого периода (datetime.date or None)\n        date_range_end: Конец анализируемого периода (datetime.date or None)\n        selected_resources: Список выбранных ресурсов для оптимизации (list or None)\n    \"\"\"\n    max_shift = settings.get('max_shift_days', 14)\n    target_load = settings.get('target_load', 85)\n    mode = settings.get('mode', 'balance')\n    \n    # Получить временную загрузку и кэш задач с учётом диапазона\n    timeline_data = parser.get_timeline_workload(date_range_start, date_range_end)\n    task_dict = {t['id']: t for t in parser.tasks}\n    \n    # Найти перегруженные периоды для каждого ресурса\n    optimization_suggestions = []\n    \n    for resource_name, weekly_loads in timeline_data.items():\n        # Фильтрация по выбранным ресурсам\n        if selected_resources and resource_name not in selected_resources:\n            continue\n        # Найти перегруженные и недозагруженные недели\n        overloaded_weeks = {}\n        underloaded_weeks = {}\n        \n        for i, week_data in enumerate(weekly_loads):\n            if week_data['percentage'] > 100:\n                overloaded_weeks[i] = week_data\n            elif week_data['percentage'] < target_load:\n                underloaded_weeks[i] = week_data\n        \n        if not overloaded_weeks:\n            continue\n        \n        # Найти задачи этого ресурса\n        resource = next((r for r in parser.resources if r['name'] == resource_name), None)\n        if not resource:\n            continue\n        \n        resource_assignments = [a for a in parser.assignments if a['resource_id'] == resource['id']]\n        \n        # Построить карту недель для быстрого поиска (один раз на ресурс)\n        # КРИТИЧНО: Использовать тот же диапазон что и в get_timeline_workload()\n        project_start = None\n        project_end = None\n        for task_item in parser.tasks:\n            if task_item['start']:\n                ts = parser._parse_date(task_item['start'])\n                if ts and (project_start is None or ts < project_start):\n                    project_start = ts\n            if task_item['finish']:\n                te = parser._parse_date(task_item['finish'])\n                if te and (project_end is None or te > project_end):\n                    project_end = te\n        \n        # Использовать выбранный диапазон или весь проект\n        if date_range_start and date_range_end:\n            from datetime import datetime as dt_class\n            range_start_dt = dt_class.combine(date_range_start, dt_class.min.time())\n            range_end_dt = dt_class.combine(date_range_end, dt_class.max.time())\n        else:\n            range_start_dt = project_start\n            range_end_dt = project_end\n        \n        if not range_start_dt or not range_end_dt:\n            continue\n            \n        current_date = range_start_dt\n        weeks_with_dates = []\n        while current_date <= range_end_dt:\n            week_end = current_date + timedelta(days=6)\n            weeks_with_dates.append({\n                'start': current_date,\n                'end': min(week_end, range_end_dt),\n                'index': len(weeks_with_dates)\n            })\n            current_date = week_end + timedelta(days=1)\n        \n        # Для каждой перегруженной недели найти задачи, которые можно сдвинуть\n        for week_idx, week_data in overloaded_weeks.items():\n            excess_hours = week_data['hours'] - week_data['capacity']\n            \n            # Получить временные границы текущей недели\n            if week_idx >= len(weeks_with_dates):\n                continue\n            current_week_info = weeks_with_dates[week_idx]\n            week_start = current_week_info['start']\n            week_end = current_week_info['end']\n            \n            # Найти задачи, пересекающиеся с этой неделей\n            tasks_in_week = []\n            for assignment in resource_assignments:\n                task = task_dict.get(assignment['task_id'])\n                if not task or not task['start'] or not task['finish']:\n                    continue\n                \n                task_start = parser._parse_date(task['start'])\n                task_end = parser._parse_date(task['finish'])\n                if not task_start or not task_end:\n                    continue\n                \n                # КРИТИЧНО: Проверить, что задача пересекается с текущей неделей\n                if task_end < week_start or task_start > week_end:\n                    continue  # Задача не пересекается с этой неделей\n                \n                task_hours = parser._parse_work_hours(assignment['work'])\n                tasks_in_week.append({\n                    'task': task,\n                    'assignment': assignment,\n                    'start': task_start,\n                    'end': task_end,\n                    'hours': task_hours\n                })\n            \n            # Попробовать сдвинуть задачи в недозагруженные периоды\n            for task_info in sorted(tasks_in_week, key=lambda x: x['hours'], reverse=True):\n                task = task_info['task']\n                task_start = task_info['start']\n                task_end = task_info['end']\n                task_hours = task_info['hours']\n                \n                best_shift = None\n                best_improvement = 0\n                \n                # Проверить все возможные сдвиги\n                for shift_days in range(1, max_shift + 1):\n                    new_start = task_start + timedelta(days=shift_days)\n                    new_end = task_end + timedelta(days=shift_days)\n                    \n                    # Найти все недели, в которые попадёт сдвинутая задача\n                    overlapping_weeks = []\n                    for week_info in weeks_with_dates:\n                        overlap_start = max(new_start, week_info['start'])\n                        overlap_end = min(new_end, week_info['end'])\n                        \n                        if overlap_start <= overlap_end:\n                            # Рассчитать долю задачи в этой неделе\n                            task_duration_days = (task_end - task_start).days + 1\n                            overlap_days = (overlap_end - overlap_start).days + 1\n                            proportion = overlap_days / task_duration_days if task_duration_days > 0 else 0\n                            hours_in_week = task_hours * proportion\n                            \n                            overlapping_weeks.append({\n                                'index': week_info['index'],\n                                'hours': hours_in_week,\n                                'proportion': proportion\n                            })\n                    \n                    if not overlapping_weeks:\n                        continue\n                    \n                    # Выбрать основную целевую неделю (с наибольшей долей задачи)\n                    main_target = max(overlapping_weeks, key=lambda w: w['proportion'])\n                    target_week_idx = main_target['index']\n                    \n                    if target_week_idx == week_idx or target_week_idx >= len(weekly_loads):\n                        continue\n                    \n                    # Проверить, что целевая неделя менее загружена\n                    target_week = weekly_loads[target_week_idx]\n                    \n                    # Рассчитать реальное улучшение в часах\n                    # Сколько часов освободится в исходной неделе\n                    hours_removed_from_source = task_hours  # Упрощение: вся задача уходит\n                    # Сколько часов добавится в целевую неделю\n                    hours_added_to_target = main_target['hours']\n                    \n                    # Проверить, что сдвиг действительно снижает перегрузку\n                    new_source_hours = week_data['hours'] - hours_removed_from_source\n                    new_source_percentage = (new_source_hours / week_data['capacity']) * 100 if week_data['capacity'] > 0 else 0\n                    \n                    new_target_hours = target_week['hours'] + hours_added_to_target\n                    new_target_percentage = (new_target_hours / target_week['capacity']) * 100 if target_week['capacity'] > 0 else 0\n                    \n                    # Условия: исходная неделя становится менее перегруженной, целевая не становится перегруженной\n                    if new_source_percentage < week_data['percentage'] and new_target_percentage <= 100:\n                        # Оценить улучшение как снижение перегрузки\n                        improvement = week_data['percentage'] - new_source_percentage\n                        \n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_shift = shift_days\n                \n                # Если нашли хороший сдвиг, добавляем рекомендацию\n                if best_shift:\n                    new_start = task_start + timedelta(days=best_shift)\n                    new_end = task_end + timedelta(days=best_shift)\n                    \n                    optimization_suggestions.append({\n                        'type': 'shift_task',\n                        'resource': resource_name,\n                        'task_name': task['name'],\n                        'task_hours': task_hours,\n                        'original_start': task_start.strftime('%Y-%m-%d'),\n                        'original_end': task_end.strftime('%Y-%m-%d'),\n                        'suggested_start': new_start.strftime('%Y-%m-%d'),\n                        'suggested_end': new_end.strftime('%Y-%m-%d'),\n                        'shift_days': best_shift,\n                        'improvement': f'{best_improvement:.1f}%',\n                        'reason': f'Снизить перегрузку на {excess_hours:.1f}ч в неделю {week_data[\"week\"]}',\n                        'priority': 'Высокий' if week_data['percentage'] > 120 else 'Средний'\n                    })\n                    \n                    # Для режима balance берём только одну задачу на неделю\n                    if mode == 'balance':\n                        break\n    \n    return optimization_suggestions\n\ndef generate_recommendations(analysis):\n    \"\"\"Generate actionable recommendations based on actual resource capacity\"\"\"\n    recommendations = []\n    \n    overloaded = analysis['overloaded']\n    underutilized = analysis['underutilized']\n    \n    if overloaded and underutilized:\n        for overloaded_resource in overloaded:\n            for underutilized_resource in underutilized:\n                # Calculate excess hours based on actual capacity\n                overload_percentage = overloaded_resource['workload_percentage'] - 100\n                excess_hours = (overload_percentage / 100) * overloaded_resource['max_capacity']\n                \n                # Calculate available capacity\n                underutil_percentage = 100 - underutilized_resource['workload_percentage']\n                available_capacity = (underutil_percentage / 100) * underutilized_resource['max_capacity']\n                \n                if available_capacity > 0:\n                    hours_to_move = min(excess_hours, available_capacity)\n                    recommendations.append({\n                        'type': 'Reassign Tasks',\n                        'from': overloaded_resource['resource_name'],\n                        'to': underutilized_resource['resource_name'],\n                        'hours': hours_to_move,\n                        'priority': 'High' if overloaded_resource['workload_percentage'] > 120 else 'Medium'\n                    })\n    \n    elif overloaded and not underutilized:\n        for resource in overloaded:\n            overload_percentage = resource['workload_percentage'] - 100\n            excess_hours = (overload_percentage / 100) * resource['max_capacity']\n            recommendations.append({\n                'type': 'Hire Additional Resources',\n                'resource': resource['resource_name'],\n                'reason': f'Overloaded by {resource[\"workload_percentage\"] - 100:.1f}% ({excess_hours:.1f} hours)',\n                'priority': 'High' if resource['workload_percentage'] > 120 else 'Medium'\n            })\n    \n    elif underutilized:\n        for resource in underutilized:\n            underutil_percentage = 100 - resource['workload_percentage']\n            available_hours = (underutil_percentage / 100) * resource['max_capacity']\n            recommendations.append({\n                'type': 'Increase Utilization',\n                'resource': resource['resource_name'],\n                'available_capacity': f'{100 - resource[\"workload_percentage\"]:.1f}% ({available_hours:.1f} hours)',\n                'priority': 'Low'\n            })\n    \n    return recommendations\n\ndef export_to_csv(workload_df, analysis, parser=None, timeline_data=None, optimization_results=None, date_start=None, date_end=None, business_days=None, capacity=None):\n    \"\"\"\n    Экспорт детального анализа в CSV с несколькими секциями:\n    1. Период анализа (если указан)\n    2. Сводка по ресурсам (всегда)\n    3. Детализация задач по ресурсам (если есть parser)\n    4. Временное распределение по неделям (если есть timeline_data)\n    5. Предложения по оптимизации (если есть optimization_results)\n    \"\"\"\n    import re\n    \n    def remove_emojis(text):\n        \"\"\"Удалить emoji из текста для совместимости с cp1251\"\"\"\n        if isinstance(text, str):\n            # Удалить emoji и другие символы Unicode за пределами cp1251\n            return re.sub(r'[^\\u0000-\\u04FF]', '', text)\n        return text\n    \n    csv_buffer = io.StringIO()\n    \n    # Период анализа (если указан)\n    if date_start and date_end:\n        period_str = f\"{date_start.strftime('%d.%m.%Y')} - {date_end.strftime('%d.%m.%Y')}\"\n        csv_buffer.write(f\"ПЕРИОД АНАЛИЗА: {period_str}\\n\")\n        if business_days is not None:\n            csv_buffer.write(f\"Рабочие дни: {business_days}\\n\")\n        if capacity is not None:\n            csv_buffer.write(f\"Рабочая ёмкость на человека: {capacity} ч.\\n\")\n        csv_buffer.write(\"\\n\")\n    \n    # Очистить DataFrame от emoji перед экспортом\n    df_clean = workload_df.copy()\n    for col in df_clean.columns:\n        if df_clean[col].dtype == 'object':\n            df_clean[col] = df_clean[col].apply(remove_emojis)\n    \n    # Секция 1: Сводка по ресурсам\n    csv_buffer.write(\"СВОДКА ПО РЕСУРСАМ\\n\")\n    df_clean.to_csv(csv_buffer, index=False)\n    csv_buffer.write(\"\\n\\n\")\n    \n    # Секция 2: Детализация задач по ресурсам\n    if parser:\n        csv_buffer.write(\"ДЕТАЛИЗАЦИЯ ЗАДАЧ ПО РЕСУРСАМ\\n\")\n        csv_buffer.write(\"Ресурс,ID задачи,Название задачи,Начало,Конец,Трудоёмкость (часы)\\n\")\n        \n        for resource in parser.resources:\n            resource_name = resource['name']\n            resource_assignments = [a for a in parser.assignments if a['resource_id'] == resource['id']]\n            \n            for assignment in resource_assignments:\n                task = next((t for t in parser.tasks if t['id'] == assignment['task_id']), None)\n                if task:\n                    task_id = task.get('id', '')\n                    task_name = task.get('name', 'Без названия')\n                    task_start = task.get('start', '')\n                    task_finish = task.get('finish', '')\n                    task_hours = parser._parse_work_hours(assignment['work'])\n                    \n                    csv_buffer.write(f'\"{resource_name}\",\"{task_id}\",\"{task_name}\",\"{task_start}\",\"{task_finish}\",{task_hours:.2f}\\n')\n        csv_buffer.write(\"\\n\\n\")\n    \n    # Секция 3: Временное распределение по неделям\n    if timeline_data:\n        csv_buffer.write(\"ВРЕМЕННОЕ РАСПРЕДЕЛЕНИЕ ПО НЕДЕЛЯМ\\n\")\n        csv_buffer.write(\"Ресурс,Неделя начало,Неделя конец,Часы,Ёмкость,Процент загрузки\\n\")\n        \n        for resource_name, weekly_loads in timeline_data.items():\n            for week_data in weekly_loads:\n                week_start = week_data['week_start'].strftime('%Y-%m-%d')\n                week_end = week_data['week_end'].strftime('%Y-%m-%d')\n                hours = week_data['hours']\n                capacity = week_data['capacity']\n                percentage = week_data['percentage']\n                \n                csv_buffer.write(f'\"{resource_name}\",{week_start},{week_end},{hours:.2f},{capacity:.2f},{percentage:.2f}\\n')\n        csv_buffer.write(\"\\n\\n\")\n    \n    # Секция 4: Предложения по оптимизации\n    if optimization_results:\n        csv_buffer.write(\"ПРЕДЛОЖЕНИЯ ПО ОПТИМИЗАЦИИ\\n\")\n        csv_buffer.write(\"Ресурс,Задача,Оригинальные даты,Предлагаемые даты,Смещение (дни),Улучшение,Причина,Приоритет\\n\")\n        \n        for suggestion in optimization_results:\n            resource = suggestion.get('resource', '')\n            task_name = suggestion.get('task_name', '')\n            orig_dates = f\"{suggestion.get('original_start', '')} - {suggestion.get('original_end', '')}\"\n            sugg_dates = f\"{suggestion.get('suggested_start', '')} - {suggestion.get('suggested_end', '')}\"\n            shift_days = suggestion.get('shift_days', '')\n            improvement = suggestion.get('improvement', '')\n            reason = suggestion.get('reason', '')\n            priority = suggestion.get('priority', '')\n            \n            csv_buffer.write(f'\"{resource}\",\"{task_name}\",\"{orig_dates}\",\"{sugg_dates}\",{shift_days},\"{improvement}\",\"{reason}\",\"{priority}\"\\n')\n        csv_buffer.write(\"\\n\")\n    \n    # Кодировка cp1251 для совместимости с Excel\n    return csv_buffer.getvalue().encode('cp1251')\n\ndef export_to_pdf(workload_df, analysis, recommendations, parser=None, timeline_data=None, optimization_results=None, date_start=None, date_end=None, business_days=None, capacity=None):\n    \"\"\"\n    Экспорт детального анализа в PDF с несколькими секциями:\n    1. Период анализа (если указан)\n    2. Сводка и таблица рабочей нагрузки (всегда)\n    3. Детализация задач по ресурсам (если есть parser)\n    4. Временное распределение по неделям (если есть timeline_data)\n    5. Предложения по оптимизации (если есть optimization_results)\n    \"\"\"\n    # Регистрация шрифтов DejaVu для поддержки кириллицы\n    dejavu_available = False\n    try:\n        pdfmetrics.registerFont(TTFont('DejaVuSans', '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf'))\n        pdfmetrics.registerFont(TTFont('DejaVuSans-Bold', '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'))\n        dejavu_available = True\n    except:\n        pass  # Если шрифты не найдены, используем стандартные Helvetica\n    \n    buffer = io.BytesIO()\n    doc = SimpleDocTemplate(buffer, pagesize=letter)\n    elements = []\n    styles = getSampleStyleSheet()\n    \n    # Выбрать шрифты в зависимости от доступности DejaVu\n    if dejavu_available:\n        normal_font = 'DejaVuSans'\n        bold_font = 'DejaVuSans-Bold'\n        # Обновление стандартных стилей для использования DejaVu Sans\n        for style_name in styles.byName:\n            style = styles[style_name]\n            style.fontName = normal_font\n    else:\n        normal_font = 'Helvetica'\n        bold_font = 'Helvetica-Bold'\n    \n    # Заголовок\n    title_style = ParagraphStyle(\n        'CustomTitle',\n        parent=styles['Heading1'],\n        fontSize=24,\n        fontName=bold_font,\n        textColor=colors.HexColor('#0078D4'),\n        spaceAfter=30\n    )\n    elements.append(Paragraph(\"Отчёт по анализу рабочей нагрузки ресурсов\", title_style))\n    elements.append(Spacer(1, 0.2*inch))\n    \n    # Период анализа (если указан)\n    if date_start and date_end:\n        period_str = f\"{date_start.strftime('%d.%m.%Y')} - {date_end.strftime('%d.%m.%Y')}\"\n        period_text = f\"<b>Период анализа:</b> {period_str}\"\n        if business_days is not None:\n            period_text += f\"<br/><b>Рабочие дни:</b> {business_days}\"\n        if capacity is not None:\n            period_text += f\"<br/><b>Рабочая ёмкость на человека:</b> {capacity} ч.\"\n        elements.append(Paragraph(period_text, styles['Normal']))\n        elements.append(Spacer(1, 0.2*inch))\n    \n    # Сводка\n    summary_text = f\"\"\"\n    <b>Сводка анализа</b><br/>\n    Создано: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br/>\n    Всего ресурсов: {len(workload_df)}<br/>\n    Перегружено: {len(analysis['overloaded'])}<br/>\n    Оптимально: {len(analysis['optimal'])}<br/>\n    Недоиспользуется: {len(analysis['underutilized'])}\n    \"\"\"\n    elements.append(Paragraph(summary_text, styles['Normal']))\n    elements.append(Spacer(1, 0.3*inch))\n    \n    # Таблица рабочей нагрузки\n    # Проверить наличие столбцов\n    has_period_hours = 'Рабочие часы за период' in workload_df.columns\n    has_percentage_col = 'Нагрузка %' in workload_df.columns\n    has_hours_col = 'Загрузка (часы)' in workload_df.columns\n    \n    # Заголовки таблицы\n    if has_period_hours:\n        if has_hours_col:\n            table_data = [['Ресурс', 'Выделено', 'Ёмкость', 'Часы за период', 'Загрузка (ч)', 'Задачи', 'Статус']]\n        else:\n            table_data = [['Ресурс', 'Выделено', 'Ёмкость', 'Часы за период', 'Нагрузка %', 'Задачи', 'Статус']]\n    else:\n        if has_hours_col:\n            table_data = [['Ресурс', 'Выделено', 'Ёмкость', 'Загрузка (ч)', 'Задачи', 'Статус']]\n        else:\n            table_data = [['Ресурс', 'Выделено', 'Ёмкость', 'Нагрузка %', 'Задачи', 'Статус']]\n    \n    for _, row in workload_df.iterrows():\n        # Вычислить процент для определения статуса\n        if has_percentage_col:\n            percentage = row['Нагрузка %']\n        elif has_hours_col and row['Ёмкость часов'] > 0:\n            percentage = (row['Загрузка (часы)'] / row['Ёмкость часов']) * 100\n        else:\n            percentage = 0\n        \n        status = 'Перегружен' if percentage > 100 else ('Оптимально' if percentage >= 70 else 'Недоиспользуется')\n        \n        # Формировать строку в зависимости от наличия колонок\n        if has_period_hours:\n            if has_hours_col:\n                table_data.append([\n                    row['Имя ресурса'],\n                    f\"{row['Выделено часов']:.1f}ч\",\n                    f\"{row['Ёмкость часов']:.1f}ч\",\n                    f\"{row['Рабочие часы за период']:.1f}ч\",\n                    f\"{row['Загрузка (часы)']:.1f}ч\",\n                    str(row['Кол-во задач']),\n                    status\n                ])\n            else:\n                table_data.append([\n                    row['Имя ресурса'],\n                    f\"{row['Выделено часов']:.1f}ч\",\n                    f\"{row['Ёмкость часов']:.1f}ч\",\n                    f\"{row['Рабочие часы за период']:.1f}ч\",\n                    f\"{row['Нагрузка %']:.1f}%\",\n                    str(row['Кол-во задач']),\n                    status\n                ])\n        else:\n            if has_hours_col:\n                table_data.append([\n                    row['Имя ресурса'],\n                    f\"{row['Выделено часов']:.1f}ч\",\n                    f\"{row['Ёмкость часов']:.1f}ч\",\n                    f\"{row['Загрузка (часы)']:.1f}ч\",\n                    str(row['Кол-во задач']),\n                    status\n                ])\n            else:\n                table_data.append([\n                    row['Имя ресурса'],\n                    f\"{row['Выделено часов']:.1f}ч\",\n                    f\"{row['Ёмкость часов']:.1f}ч\",\n                    f\"{row['Нагрузка %']:.1f}%\",\n                    str(row['Кол-во задач']),\n                    status\n                ])\n    \n    table = Table(table_data)\n    table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#0078D4')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n        ('FONTNAME', (0, 0), (-1, 0), bold_font),\n        ('FONTNAME', (0, 1), (-1, -1), normal_font),\n        ('FONTSIZE', (0, 0), (-1, 0), 12),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black)\n    ]))\n    \n    elements.append(table)\n    elements.append(Spacer(1, 0.3*inch))\n    \n    # Рекомендации\n    if recommendations:\n        heading_style = ParagraphStyle(\n            'CustomHeading2',\n            parent=styles['Heading2'],\n            fontName=bold_font\n        )\n        elements.append(Paragraph(\"<b>Рекомендации</b>\", heading_style))\n        for i, rec in enumerate(recommendations[:10], 1):\n            if rec['type'] == 'Reassign Tasks':\n                rec_text = f\"{i}. Перераспределить задачи - Перенести {rec['hours']:.1f}ч от {rec['from']} к {rec['to']}\"\n            elif rec['type'] == 'Hire Additional Resources':\n                rec_text = f\"{i}. Нанять дополнительные ресурсы для {rec['resource']}: {rec['reason']}\"\n            else:\n                rec_text = f\"{i}. Увеличить использование {rec['resource']}: {rec['available_capacity']}\"\n            elements.append(Paragraph(rec_text, styles['Normal']))\n    \n    # Секция: Детализация задач по ресурсам\n    if parser:\n        elements.append(Spacer(1, 0.5*inch))\n        heading_style = ParagraphStyle(\n            'CustomHeading2',\n            parent=styles['Heading2'],\n            fontName=bold_font\n        )\n        elements.append(Paragraph(\"<b>Детализация задач по ресурсам</b>\", heading_style))\n        elements.append(Spacer(1, 0.2*inch))\n        \n        # Создать таблицу задач (ограничить до 50 задач для читаемости)\n        task_table_data = [['Ресурс', 'Задача', 'Начало', 'Конец', 'Часы']]\n        task_count = 0\n        max_tasks = 50\n        \n        for resource in parser.resources[:10]:  # Ограничить до 10 ресурсов\n            resource_name = resource['name']\n            resource_assignments = [a for a in parser.assignments if a['resource_id'] == resource['id']]\n            \n            for assignment in resource_assignments[:5]:  # До 5 задач на ресурс\n                if task_count >= max_tasks:\n                    break\n                task = next((t for t in parser.tasks if t['id'] == assignment['task_id']), None)\n                if task:\n                    task_name = task.get('name', 'Без названия')[:30]  # Обрезать длинные имена\n                    task_start = task.get('start', '')[:10] if task.get('start') else ''\n                    task_finish = task.get('finish', '')[:10] if task.get('finish') else ''\n                    task_hours = parser._parse_work_hours(assignment['work'])\n                    \n                    task_table_data.append([\n                        resource_name[:20],\n                        task_name,\n                        task_start,\n                        task_finish,\n                        f\"{task_hours:.1f}ч\"\n                    ])\n                    task_count += 1\n            \n            if task_count >= max_tasks:\n                break\n        \n        if len(task_table_data) > 1:\n            task_table = Table(task_table_data, colWidths=[1.2*inch, 2.5*inch, 1*inch, 1*inch, 0.8*inch])\n            task_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#0078D4')),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n                ('FONTNAME', (0, 0), (-1, 0), bold_font),\n                ('FONTNAME', (0, 1), (-1, -1), normal_font),\n                ('FONTSIZE', (0, 0), (-1, 0), 10),\n                ('FONTSIZE', (0, 1), (-1, -1), 8),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)\n            ]))\n            elements.append(task_table)\n    \n    # Секция: Временное распределение по неделям\n    if timeline_data:\n        elements.append(Spacer(1, 0.5*inch))\n        heading_style = ParagraphStyle(\n            'CustomHeading2',\n            parent=styles['Heading2'],\n            fontName=bold_font\n        )\n        elements.append(Paragraph(\"<b>Временное распределение по неделям</b>\", heading_style))\n        elements.append(Spacer(1, 0.2*inch))\n        \n        # Создать таблицу недель (ограничить для читаемости)\n        week_table_data = [['Ресурс', 'Период', 'Часы', 'Ёмкость', 'Загрузка %']]\n        week_count = 0\n        max_weeks = 40\n        \n        for resource_name, weekly_loads in list(timeline_data.items())[:5]:  # До 5 ресурсов\n            for week_data in weekly_loads[:8]:  # До 8 недель на ресурс\n                if week_count >= max_weeks:\n                    break\n                week_label = week_data['week']\n                hours = week_data['hours']\n                capacity = week_data['capacity']\n                percentage = week_data['percentage']\n                \n                week_table_data.append([\n                    resource_name[:20],\n                    week_label,\n                    f\"{hours:.1f}ч\",\n                    f\"{capacity:.1f}ч\",\n                    f\"{percentage:.1f}%\"\n                ])\n                week_count += 1\n            \n            if week_count >= max_weeks:\n                break\n        \n        if len(week_table_data) > 1:\n            week_table = Table(week_table_data, colWidths=[1.5*inch, 1.5*inch, 1*inch, 1*inch, 1*inch])\n            week_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#0078D4')),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n                ('FONTNAME', (0, 0), (-1, 0), bold_font),\n                ('FONTNAME', (0, 1), (-1, -1), normal_font),\n                ('FONTSIZE', (0, 0), (-1, 0), 10),\n                ('FONTSIZE', (0, 1), (-1, -1), 8),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)\n            ]))\n            elements.append(week_table)\n    \n    # Секция: Детальные предложения по оптимизации\n    if optimization_results:\n        elements.append(Spacer(1, 0.5*inch))\n        heading_style = ParagraphStyle(\n            'CustomHeading2',\n            parent=styles['Heading2'],\n            fontName=bold_font\n        )\n        elements.append(Paragraph(\"<b>Детальные предложения по оптимизации</b>\", heading_style))\n        elements.append(Spacer(1, 0.2*inch))\n        \n        # Создать таблицу оптимизации\n        opt_table_data = [['Ресурс', 'Задача', 'Смещение', 'Улучшение', 'Причина']]\n        \n        for i, suggestion in enumerate(optimization_results[:20]):  # До 20 предложений\n            resource = suggestion.get('resource', '')[:15]\n            task_name = suggestion.get('task_name', '')[:20]\n            shift_info = f\"{suggestion.get('shift_days', '')} дн.\"\n            improvement = suggestion.get('improvement', '')\n            reason = suggestion.get('reason', '')[:40]\n            \n            opt_table_data.append([\n                resource,\n                task_name,\n                shift_info,\n                improvement,\n                reason\n            ])\n        \n        if len(opt_table_data) > 1:\n            opt_table = Table(opt_table_data, colWidths=[1*inch, 1.5*inch, 0.8*inch, 0.8*inch, 2.4*inch])\n            opt_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#0078D4')),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n                ('FONTNAME', (0, 0), (-1, 0), bold_font),\n                ('FONTNAME', (0, 1), (-1, -1), normal_font),\n                ('FONTSIZE', (0, 0), (-1, 0), 10),\n                ('FONTSIZE', (0, 1), (-1, -1), 7),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)\n            ]))\n            elements.append(opt_table)\n    \n    doc.build(elements)\n    buffer.seek(0)\n    return buffer\n\ndef calculate_business_days(start_date, end_date):\n    \"\"\"Рассчитывает количество рабочих дней между двумя датами (исключая субботу и воскресенье)\"\"\"\n    if not start_date or not end_date:\n        return 0\n    \n    business_days = 0\n    current_date = start_date\n    \n    while current_date <= end_date:\n        # weekday(): 0=Monday, 1=Tuesday, ..., 6=Sunday\n        if current_date.weekday() < 5:  # 0-4 это пн-пт\n            business_days += 1\n        current_date += timedelta(days=1)\n    \n    return business_days\n\ndef calculate_work_capacity(business_days):\n    \"\"\"Рассчитывает рабочую емкость одного человека в часах (дни × 8 часов)\"\"\"\n    return business_days * 8\n\ndef calculate_actual_hours_per_resource(parser, date_start, date_end):\n    \"\"\"Рассчитывает фактические рабочие часы для каждого ресурса за указанный период\"\"\"\n    if not parser:\n        return {}\n    \n    resource_hours = {}\n    \n    # Получить все задачи из parser\n    for task in parser.tasks:\n        task_start_raw = task.get('start')\n        task_end_raw = task.get('finish')\n        \n        if not task_start_raw or not task_end_raw:\n            continue\n        \n        # Преобразовать в date если это datetime\n        if isinstance(task_start_raw, str):\n            try:\n                task_start = datetime.fromisoformat(task_start_raw).date()\n            except:\n                continue\n        elif isinstance(task_start_raw, datetime):\n            task_start = task_start_raw.date()\n        else:\n            task_start = task_start_raw\n            \n        if isinstance(task_end_raw, str):\n            try:\n                task_end = datetime.fromisoformat(task_end_raw).date()\n            except:\n                continue\n        elif isinstance(task_end_raw, datetime):\n            task_end = task_end_raw.date()\n        else:\n            task_end = task_end_raw\n        \n        # Проверить пересечение с выбранным диапазоном\n        if task_end < date_start or task_start > date_end:\n            continue\n        \n        # Пересечение диапазонов\n        overlap_start = max(task_start, date_start)\n        overlap_end = min(task_end, date_end)\n        \n        # Найти все назначения для этой задачи\n        task_assignments = [a for a in parser.assignments if a['task_id'] == task['id']]\n        \n        for assignment in task_assignments:\n            resource_id = assignment.get('resource_id')\n            if not resource_id:\n                continue\n                \n            # Найти имя ресурса\n            resource = next((r for r in parser.resources if r['id'] == resource_id), None)\n            if not resource:\n                continue\n                \n            resource_name = resource['name']\n            work_hours = parser._parse_work_hours(assignment.get('work', '0'))\n            \n            # Пропорция задачи в выбранном диапазоне\n            task_duration_days = (task_end - task_start).days + 1\n            overlap_duration_days = (overlap_end - overlap_start).days + 1\n            \n            if task_duration_days > 0:\n                proportion = overlap_duration_days / task_duration_days\n                hours_in_range = work_hours * proportion\n            else:\n                hours_in_range = work_hours\n            \n            # Суммировать часы для ресурса\n            if resource_name not in resource_hours:\n                resource_hours[resource_name] = 0\n            resource_hours[resource_name] += hours_in_range\n    \n    return resource_hours\n\n# Initialize session state\nif 'workload_data' not in st.session_state:\n    st.session_state.workload_data = None\nif 'analysis' not in st.session_state:\n    st.session_state.analysis = None\nif 'parser' not in st.session_state:\n    st.session_state.parser = None\nif 'optimization_results' not in st.session_state:\n    st.session_state.optimization_results = None\nif 'timeline_data' not in st.session_state:\n    st.session_state.timeline_data = None\nif 'resource_replacements' not in st.session_state:\n    st.session_state.resource_replacements = {}\nif 'date_range_start' not in st.session_state:\n    st.session_state.date_range_start = None\nif 'date_range_end' not in st.session_state:\n    st.session_state.date_range_end = None\nif 'resource_groups' not in st.session_state:\n    st.session_state.resource_groups = {}\nif 'display_mode' not in st.session_state:\n    st.session_state.display_mode = 'percentage'  # По умолчанию проценты\n\n# Main application\ndef main():\n    # Заголовок\n    st.markdown(\"\"\"\n        <h1 style='color: #0078D4; margin-bottom: 10px;'>📊 Анализатор управления ресурсами</h1>\n        <p style='color: #323130; font-size: 16px; margin-bottom: 30px;'>\n            Анализируйте файлы Microsoft Project для выявления дисбаланса рабочей нагрузки и оптимизации распределения ресурсов\n        </p>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Боковая панель\n    with st.sidebar:\n        # Переключатель отображения загрузки\n        st.markdown(\"###  Отображение загрузки\")\n        display_options = {\n            'percentage': 'В процентах',\n            'hours': 'В часах'\n        }\n        \n        selected_display = st.radio(\n            \"Выберите формат:\",\n            options=list(display_options.keys()),\n            format_func=lambda x: display_options[x],\n            key='display_selector',\n            label_visibility='collapsed'\n        )\n        \n        # Если режим отображения изменился, обновляем session_state и перезагружаем\n        if selected_display != st.session_state.display_mode:\n            st.session_state.display_mode = selected_display\n            st.rerun()\n        \n        st.markdown(\"---\")\n        \n        st.markdown(\"### 📁 Загрузка файла MS Project\")\n        st.markdown(\"Поддерживаемые форматы: .xml, .mspdi\")\n        st.info(\"💡 Чтобы экспортировать .mpp в XML: в MS Project выберите Файл → Сохранить как → выберите Формат XML (*.xml)\")\n        \n        uploaded_file = st.file_uploader(\n            \"Выберите файл\",\n            type=['xml', 'mspdi'],\n            help=\"Загрузите ваш XML-файл Microsoft Project\"\n        )\n        \n        # Сохранить содержимое файла как байты для надежности при st.rerun()\n        if uploaded_file is not None:\n            st.session_state.uploaded_file_content = uploaded_file.getvalue()\n            st.session_state.uploaded_file_name = uploaded_file.name\n        \n        # Проверить наличие загруженного файла\n        has_file = (uploaded_file is not None) or ('uploaded_file_content' in st.session_state)\n        \n        if has_file:\n            file_name = uploaded_file.name if uploaded_file is not None else st.session_state.get('uploaded_file_name', 'файл')\n            st.success(f\"✓ {file_name} загружен\")\n            \n            if st.button(\"🔄 Анализировать файл\", use_container_width=True):\n                with st.spinner(\"Анализ файла MS Project...\"):\n                    # Использовать сохраненное содержимое или прочитать новый файл\n                    if uploaded_file is not None:\n                        file_content = uploaded_file.getvalue()\n                    else:\n                        file_content = st.session_state.uploaded_file_content\n                    \n                    parser = MSProjectParser(file_content)\n                    \n                    if parser.parse():\n                        st.session_state.parser = parser\n                        # Инициализировать даты проекта на основе текущей даты\n                        today = datetime.now().date()\n                        \n                        # Получить даты проекта для ограничения\n                        project_start, project_end = parser.get_project_dates()\n                        \n                        # Начало: текущая дата - 7 дней, округленная до понедельника\n                        start_candidate = today - timedelta(days=7)\n                        days_since_monday = start_candidate.weekday()\n                        default_start = start_candidate - timedelta(days=days_since_monday)\n                        \n                        # Конец: текущая дата + 14 дней, округленная до пятницы\n                        end_candidate = today + timedelta(days=14)\n                        days_until_friday = (4 - end_candidate.weekday()) % 7\n                        default_end = end_candidate + timedelta(days=days_until_friday)\n                        \n                        # Ограничить даты в пределах проекта\n                        if project_start and project_end:\n                            project_start_date = project_start.date()\n                            project_end_date = project_end.date()\n                            default_start = max(default_start, project_start_date)\n                            default_start = min(default_start, project_end_date)\n                            default_end = max(default_end, project_start_date)\n                            default_end = min(default_end, project_end_date)\n                        \n                        st.session_state.date_range_start = default_start\n                        st.session_state.date_range_end = default_end\n                        # Рассчитать данные с учетом выбранного диапазона\n                        st.session_state.workload_data = parser.get_resource_workload_data(\n                            st.session_state.date_range_start,\n                            st.session_state.date_range_end\n                        )\n                        st.session_state.analysis = analyze_workload(st.session_state.workload_data)\n                        st.success(\"✓ Файл успешно проанализирован!\")\n                        st.rerun()\n                    else:\n                        st.error(\"Не удалось проанализировать файл\")\n        \n        # Фильтр временного диапазона\n        if st.session_state.parser is not None:\n            st.markdown(\"---\")\n            st.markdown(\"### 📅 Временной диапазон анализа\")\n            \n            # Получить даты проекта\n            project_start, project_end = st.session_state.parser.get_project_dates()\n            \n            if project_start and project_end:\n                col1, col2 = st.columns(2)\n                with col1:\n                    start_date = st.date_input(\n                        \"Начало\",\n                        value=st.session_state.date_range_start or project_start.date(),\n                        min_value=project_start.date(),\n                        max_value=project_end.date(),\n                        help=\"Начальная дата анализа\"\n                    )\n                with col2:\n                    end_date = st.date_input(\n                        \"Конец\",\n                        value=st.session_state.date_range_end or project_end.date(),\n                        min_value=project_start.date(),\n                        max_value=project_end.date(),\n                        help=\"Конечная дата анализа\"\n                    )\n                \n                # Обновить session state если изменились\n                if start_date != st.session_state.date_range_start or end_date != st.session_state.date_range_end:\n                    st.session_state.date_range_start = start_date\n                    st.session_state.date_range_end = end_date\n                    # Пересчитать данные с учетом нового диапазона\n                    if st.session_state.parser:\n                        st.session_state.workload_data = st.session_state.parser.get_resource_workload_data(\n                            st.session_state.date_range_start,\n                            st.session_state.date_range_end\n                        )\n                        st.session_state.analysis = analyze_workload(st.session_state.workload_data)\n                        # Сбросить timeline_data и optimization_results для пересчета\n                        st.session_state.timeline_data = None\n                        st.session_state.optimization_results = None\n                    st.rerun()\n        \n        st.markdown(\"---\")\n        st.markdown(\"### ℹ️ О программе\")\n        st.markdown(\"\"\"\n        Этот инструмент помогает:\n        - Выявить перегруженные ресурсы (>100%)\n        - Найти недоиспользованные мощности (<70%)\n        - **Оптимизировать распределение смещением задач**\n        - **Анализировать временную загрузку по неделям**\n        - **Интерактивно заменять специалистов**\n        - Получить рекомендации по балансировке нагрузки\n        - Экспортировать отчёты анализа\n        \"\"\")\n    \n    # Основной контент\n    if st.session_state.workload_data is None:\n        # Экран приветствия\n        st.info(\"👆 Загрузите XML-файл Microsoft Project для начала анализа\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.markdown(\"\"\"\n                <div class='metric-card'>\n                    <h3 style='color: #FF4B4B;'>Выявление перегрузки</h3>\n                    <p>Определение ресурсов с нагрузкой более 100%</p>\n                </div>\n            \"\"\", unsafe_allow_html=True)\n        \n        with col2:\n            st.markdown(\"\"\"\n                <div class='metric-card'>\n                    <h3 style='color: #107C10;'>Оптимизация распределения</h3>\n                    <p>Рекомендации по улучшению распределения ресурсов</p>\n                </div>\n            \"\"\", unsafe_allow_html=True)\n        \n        with col3:\n            st.markdown(\"\"\"\n                <div class='metric-card'>\n                    <h3 style='color: #0078D4;'>Экспорт отчётов</h3>\n                    <p>Скачайте анализ в формате CSV или PDF</p>\n                </div>\n            \"\"\", unsafe_allow_html=True)\n        \n        st.markdown(\"### 📋 Пример анализа\")\n        st.markdown(\"Загрузите файл, чтобы увидеть подробный анализ ресурсов с:\")\n        st.markdown(\"- Цветными индикаторами рабочей нагрузки\")\n        st.markdown(\"- Назначениями задач по ресурсам\")\n        st.markdown(\"- Практическими рекомендациями\")\n        st.markdown(\"- Сводной статистикой\")\n        \n    else:\n        # Отображение анализа\n        workload_data = st.session_state.workload_data\n        analysis = st.session_state.analysis\n        \n        # Сводные метрики\n        st.markdown(\"### 📊 Панель управления\")\n        \n        # Получение информации о длительности проекта\n        project_weeks = workload_data[0]['project_weeks'] if workload_data else 4\n        \n        col1, col2, col3, col4, col5 = st.columns(5)\n        \n        with col1:\n            st.metric(\"Всего ресурсов\", len(workload_data))\n        \n        with col2:\n            st.metric(\"Длительность проекта\", f\"{project_weeks:.1f} нед.\")\n        \n        with col3:\n            st.metric(\"Перегружено\", len(analysis['overloaded']), \n                     delta=f\"{len(analysis['overloaded'])}\" if len(analysis['overloaded']) > 0 else None,\n                     delta_color=\"inverse\")\n        \n        with col4:\n            st.metric(\"Оптимально\", len(analysis['optimal']),\n                     delta_color=\"off\")\n        \n        with col5:\n            st.metric(\"Недоиспользуется\", len(analysis['underutilized']),\n                     delta=f\"{len(analysis['underutilized'])}\" if len(analysis['underutilized']) > 0 else None,\n                     delta_color=\"normal\")\n        \n        # Информация о периоде анализа\n        if st.session_state.date_range_start and st.session_state.date_range_end:\n            business_days = calculate_business_days(st.session_state.date_range_start, st.session_state.date_range_end)\n            work_capacity = calculate_work_capacity(business_days)\n            \n            # Material Design 3 панель управления периодом\n            period_str = f\"{st.session_state.date_range_start.strftime('%d.%m.%Y')} - {st.session_state.date_range_end.strftime('%d.%m.%Y')}\"\n            st.markdown(md3_info_panel(period_str, business_days, work_capacity), unsafe_allow_html=True)\n        \n        st.markdown(\"---\")\n        \n        # Объединенная секция управления персоналом\n        st.markdown(\"### 👥 Управление персоналом\")\n        \n        # Инициализация applied_group если нужно\n        if not hasattr(st.session_state, 'applied_group'):\n            st.session_state.applied_group = None\n        \n        # Инициализация переменных для использования вне табов\n        selected_resources = []\n        display_data = workload_data\n        \n        # Два таба: Текущий выбор и Сохраненные группы\n        tab1, tab2 = st.tabs([\"🔍 Текущий выбор\", \"💾 Сохраненные группы\"])\n        \n        # ========== ТАБ 1: ТЕКУЩИЙ ВЫБОР ==========\n        with tab1:\n            all_names = [item['resource_name'] for item in workload_data]\n            \n            # Поиск по имени\n            col1, col2 = st.columns([3, 1])\n            with col1:\n                search_term = st.text_input(\"Поиск по фамилии или имени:\", placeholder=\"например, Иванов\")\n            with col2:\n                st.markdown(\"<br>\", unsafe_allow_html=True)\n                show_all = st.checkbox(\"Показать всех\", value=True)\n            \n            # Фильтрация данных по поиску\n            if show_all or not search_term:\n                filtered_data = workload_data\n            else:\n                filtered_data = [item for item in workload_data \n                               if search_term.lower() in item['resource_name'].lower()]\n            \n            if not filtered_data:\n                st.warning(\"Ресурсы, соответствующие вашему запросу, не найдены.\")\n                selected_resources = []\n                display_data = []\n            else:\n                # Определить default значения для multiselect\n                if st.session_state.applied_group:\n                    # Группа применена: использовать ресурсы из группы как default (но не ограничивать options)\n                    group_name, group_resources = st.session_state.applied_group\n                    st.info(f\"📌 Применена группа '{group_name}' ({len(group_resources)} чел.). Вы можете добавить дополнительные ресурсы из списка ниже.\")\n                    # Default - только ресурсы из группы, которые есть в filtered_data\n                    default_resources = [name for name in group_resources \n                                       if name in [item['resource_name'] for item in filtered_data]]\n                else:\n                    # Группа не применена: выбрать всех из filtered_data\n                    default_resources = [item['resource_name'] for item in filtered_data]\n                \n                # Множественный выбор - options всегда содержат ВСЕ ресурсы из filtered_data\n                selected_resources = st.multiselect(\n                    \"Выберите конкретные ресурсы для анализа:\",\n                    options=[item['resource_name'] for item in filtered_data],\n                    default=default_resources,\n                    key=\"current_selection_multiselect\"\n                )\n                \n                # НОВАЯ ФУНКЦИЯ: Быстрое сохранение текущего выбора как группы\n                if selected_resources and len(selected_resources) > 0:\n                    st.markdown(\"---\")\n                    with st.expander(\"💾 Сохранить текущий выбор как группу\"):\n                        quick_group_name = st.text_input(\n                            \"Название новой группы:\",\n                            placeholder=\"например, Команда А\",\n                            key=\"quick_save_group_name\"\n                        )\n                        if st.button(\"💾 Сохранить\", key=\"quick_save_btn\"):\n                            if not quick_group_name:\n                                st.error(\"Введите название группы\")\n                            elif quick_group_name in st.session_state.resource_groups:\n                                st.error(\"Группа с таким названием уже существует\")\n                            else:\n                                st.session_state.resource_groups[quick_group_name] = selected_resources.copy()\n                                st.success(f\"✓ Группа '{quick_group_name}' создана ({len(selected_resources)} чел.)\")\n                                st.rerun()\n                \n                if selected_resources:\n                    display_data = [item for item in filtered_data \n                                  if item['resource_name'] in selected_resources]\n                else:\n                    display_data = filtered_data\n        \n        # ========== ТАБ 2: СОХРАНЕННЫЕ ГРУППЫ ==========\n        with tab2:\n            # Выбор и применение сохраненной группы\n            if st.session_state.resource_groups:\n                st.markdown(\"**Применить сохраненную группу:**\")\n                group_names = [\"-- Не выбрано --\"] + list(st.session_state.resource_groups.keys())\n                selected_group = st.selectbox(\n                    \"Выберите группу:\",\n                    options=group_names,\n                    key=\"selected_group_dropdown\"\n                )\n                \n                # Кнопка для применения группы\n                if selected_group != \"-- Не выбрано --\":\n                    group_resources = st.session_state.resource_groups[selected_group]\n                    st.caption(f\"👥 {len(group_resources)} человек: {', '.join(group_resources[:3])}{'...' if len(group_resources) > 3 else ''}\")\n                    \n                    if st.button(\"✅ Применить группу\", key=\"apply_group_btn\"):\n                        st.session_state.applied_group = (selected_group, group_resources)\n                        st.success(f\"✓ Группа '{selected_group}' применена ({len(group_resources)} чел.)\")\n                        st.rerun()\n                \n                st.markdown(\"---\")\n            else:\n                st.info(\"У вас пока нет сохраненных групп. Создайте новую ниже.\")\n            \n            # Создание новой группы с нуля\n            st.markdown(\"**Создать новую группу:**\")\n            with st.expander(\"➕ Создать группу\", expanded=not st.session_state.resource_groups):\n                new_group_name = st.text_input(\"Название группы:\", placeholder=\"например, Разработчики\", key=\"new_group_name_input\")\n                \n                all_names = [item['resource_name'] for item in workload_data]\n                new_group_resources = st.multiselect(\n                    \"Выберите участников группы:\",\n                    options=all_names,\n                    key=\"new_group_resources\"\n                )\n                \n                if st.button(\"💾 Сохранить группу\", key=\"save_new_group_btn\"):\n                    if not new_group_name:\n                        st.error(\"Введите название группы\")\n                    elif not new_group_resources:\n                        st.error(\"Выберите хотя бы одного участника\")\n                    elif new_group_name in st.session_state.resource_groups:\n                        st.error(\"Группа с таким названием уже существует\")\n                    else:\n                        st.session_state.resource_groups[new_group_name] = new_group_resources\n                        st.success(f\"✓ Группа '{new_group_name}' создана ({len(new_group_resources)} чел.)\")\n                        st.rerun()\n            \n            # Управление существующими группами\n            if st.session_state.resource_groups:\n                st.markdown(\"---\")\n                st.markdown(\"**Управление группами:**\")\n                for group_name in list(st.session_state.resource_groups.keys()):\n                    group_members = st.session_state.resource_groups[group_name]\n                    \n                    # Заголовок группы с кнопкой удаления\n                    col1, col2 = st.columns([4, 1])\n                    with col1:\n                        st.markdown(f\"**{group_name}** ({len(group_members)} чел.)\")\n                    with col2:\n                        if st.button(\"🗑️\", key=f\"delete_{group_name}\", help=f\"Удалить группу '{group_name}'\"):\n                            del st.session_state.resource_groups[group_name]\n                            if st.session_state.applied_group and st.session_state.applied_group[0] == group_name:\n                                st.session_state.applied_group = None\n                            st.success(f\"✓ Группа '{group_name}' удалена\")\n                            st.rerun()\n                    \n                    # Expander с полным составом группы\n                    with st.expander(f\"👁️ Просмотр состава группы '{group_name}'\"):\n                        if len(group_members) > 0:\n                            # Вывести всех участников в виде нумерованного списка\n                            for idx, member in enumerate(group_members, 1):\n                                st.text(f\"{idx}. {member}\")\n                        else:\n                            st.caption(\"Группа пуста\")\n                    \n                    st.markdown(\"\")  # Добавить отступ между группами\n        \n        st.markdown(\"---\")\n        \n        # Проверка что есть данные для отображения\n        if not selected_resources and not display_data:\n            st.info(\"Выберите ресурсы для анализа в табе 'Текущий выбор'\")\n        else:\n            # Таблица анализа рабочей нагрузки\n            st.markdown(\"### 📈 Анализ рабочей нагрузки\")\n            \n            # Применить MD3 стили для таблиц\n            st.markdown(get_md3_table_style(), unsafe_allow_html=True)\n            \n            # Рассчитать фактические часы для каждого ресурса за период\n            actual_hours_dict = {}\n            if st.session_state.parser and st.session_state.date_range_start and st.session_state.date_range_end:\n                actual_hours_dict = calculate_actual_hours_per_resource(\n                    st.session_state.parser,\n                    st.session_state.date_range_start,\n                    st.session_state.date_range_end\n                )\n            \n            # Подготовка датафрейма\n            df_data = []\n            for item in display_data:\n                percentage = item['workload_percentage']\n                resource_name = item['resource_name']\n                capacity = item['max_capacity']\n                \n                # Получить фактические часы за период\n                actual_hours = actual_hours_dict.get(resource_name, 0.0)\n                \n                # Рассчитать загрузку в часах\n                workload_hours = (capacity * percentage / 100) if capacity > 0 else 0\n                \n                # Индикатор статуса\n                if percentage > 100:\n                    status = \"🔴 Перегружен\"\n                    status_color = \"#FF4B4B\"\n                elif percentage >= 70:\n                    status = \"🟢 Оптимально\"\n                    status_color = \"#107C10\"\n                else:\n                    status = \"🟡 Недоиспользуется\"\n                    status_color = \"#FFB900\"\n                \n                # Формируем строку в зависимости от режима отображения\n                row_data = {\n                    'Имя ресурса': resource_name,\n                    'Выделено часов': item['total_work_hours'],\n                    'Ёмкость часов': capacity,\n                    'Рабочие часы за период': actual_hours\n                }\n                \n                # Добавляем колонку загрузки в зависимости от режима\n                if st.session_state.display_mode == 'hours':\n                    row_data['Загрузка (часы)'] = workload_hours\n                else:\n                    row_data['Нагрузка %'] = percentage\n                \n                row_data['Кол-во задач'] = item['task_count']\n                row_data['Статус'] = status\n                \n                df_data.append(row_data)\n            \n            df = pd.DataFrame(df_data)\n            \n            # Раскраска датафрейма\n            def highlight_workload(row):\n                # Определяем процент в зависимости от режима отображения\n                if st.session_state.display_mode == 'hours':\n                    # В режиме часов нужно пересчитать процент из часов\n                    capacity = row['Ёмкость часов']\n                    if capacity > 0:\n                        pct = (row['Загрузка (часы)'] / capacity) * 100\n                    else:\n                        pct = 0\n                else:\n                    pct = row['Нагрузка %']\n                \n                if pct > 100:\n                    return ['background-color: #FFE5E5'] * len(row)\n                elif pct < 70:\n                    return ['background-color: #FFF4E5'] * len(row)\n                else:\n                    return ['background-color: #E5F5E5'] * len(row)\n            \n            # Форматирование в зависимости от режима\n            format_dict = {\n                'Выделено часов': '{:.1f}',\n                'Ёмкость часов': '{:.1f}',\n                'Рабочие часы за период': '{:.1f}'\n            }\n            \n            if st.session_state.display_mode == 'hours':\n                format_dict['Загрузка (часы)'] = '{:.1f}'\n            else:\n                format_dict['Нагрузка %'] = '{:.1f}%'\n            \n            styled_df = df.style.apply(highlight_workload, axis=1).format(format_dict)\n            \n            st.dataframe(styled_df, use_container_width=True, hide_index=True)\n            \n            # Детализация задач\n            st.markdown(\"### 📋 Детализация задач\")\n            \n            for item in display_data:\n                with st.expander(f\"{item['resource_name']} - {item['workload_percentage']:.1f}% нагрузка\"):\n                    if item['tasks']:\n                        task_df = pd.DataFrame(item['tasks'])\n                        st.dataframe(task_df, use_container_width=True, hide_index=True)\n                    else:\n                        st.info(\"Задачи не назначены\")\n            \n            # Рекомендации\n            st.markdown(\"### 💡 Рекомендации\")\n            \n            # Фильтрация analysis по выбранным ресурсам\n            if selected_resources:\n                filtered_analysis = {\n                    'overloaded': [r for r in analysis['overloaded'] if r['resource_name'] in selected_resources],\n                    'optimal': [r for r in analysis['optimal'] if r['resource_name'] in selected_resources],\n                    'underutilized': [r for r in analysis['underutilized'] if r['resource_name'] in selected_resources]\n                }\n            else:\n                filtered_analysis = analysis\n            \n            recommendations = generate_recommendations(filtered_analysis)\n            \n            if recommendations:\n                for i, rec in enumerate(recommendations, 1):\n                    priority_color = {\n                        'High': '#FF4B4B',\n                        'Medium': '#FFB900',\n                        'Low': '#107C10'\n                    }.get(rec.get('priority', 'Low'), '#107C10')\n                    \n                    priority_text = {\n                        'High': 'Высокий приоритет',\n                        'Medium': 'Средний приоритет',\n                        'Low': 'Низкий приоритет'\n                    }.get(rec.get('priority', 'Low'), 'Низкий приоритет')\n                    \n                    if rec['type'] == 'Reassign Tasks':\n                        st.markdown(f\"\"\"\n                        <div style='background-color: white; padding: 15px; border-radius: 8px; \n                                    margin: 10px 0; border-left: 4px solid {priority_color}'>\n                            <b>{i}. Перераспределить задачи</b> \n                            <span style='background-color: {priority_color}; color: white; \n                                         padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 10px'>\n                                {priority_text}\n                            </span><br/>\n                            Перенести <b>{rec['hours']:.1f} часов</b> работы от \n                            <b>{rec['from']}</b> к <b>{rec['to']}</b>\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n                    elif rec['type'] == 'Hire Additional Resources':\n                        st.markdown(f\"\"\"\n                        <div style='background-color: white; padding: 15px; border-radius: 8px; \n                                    margin: 10px 0; border-left: 4px solid {priority_color}'>\n                            <b>{i}. Нанять дополнительные ресурсы</b>\n                            <span style='background-color: {priority_color}; color: white; \n                                         padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 10px'>\n                                {priority_text}\n                            </span><br/>\n                            Рассмотрите найм дополнительных ресурсов для поддержки <b>{rec['resource']}</b><br/>\n                            Причина: {rec['reason']}\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n                    else:\n                        st.markdown(f\"\"\"\n                        <div style='background-color: white; padding: 15px; border-radius: 8px; \n                                    margin: 10px 0; border-left: 4px solid {priority_color}'>\n                            <b>{i}. Увеличить использование</b>\n                            <span style='background-color: {priority_color}; color: white; \n                                         padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 10px'>\n                                {priority_text}\n                            </span><br/>\n                            <b>{rec['resource']}</b> имеет {rec['available_capacity']} доступной мощности\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n            else:\n                st.success(\"✓ Все ресурсы распределены оптимально!\")\n            \n            # Оптимизация с смещением задач\n            st.markdown(\"---\")\n            st.markdown(\"## ⚙️ Интеллектуальная оптимизация\")\n            \n            with st.expander(\"🎯 Настройки оптимизации\", expanded=True):\n                col_opt1, col_opt2, col_opt3 = st.columns(3)\n                \n                with col_opt1:\n                    max_shift_days = st.slider(\n                        \"Максимальное смещение задач (дни)\",\n                        min_value=1,\n                        max_value=30,\n                        value=14,\n                        help=\"Насколько далеко можно сдвигать задачи для оптимизации\"\n                    )\n                \n                with col_opt2:\n                    target_load = st.slider(\n                        \"Целевая загрузка (%)\",\n                        min_value=70,\n                        max_value=100,\n                        value=85,\n                        help=\"Желаемый уровень загрузки ресурсов\"\n                    )\n                \n                with col_opt3:\n                    opt_mode = st.selectbox(\n                        \"Режим оптимизации\",\n                        options=['balance', 'minimize_peaks'],\n                        format_func=lambda x: 'Балансировка загрузки' if x == 'balance' else 'Минимизация пиков',\n                        help=\"Стратегия оптимизации распределения\"\n                    )\n                \n                if st.button(\"🚀 Запустить оптимизацию\", use_container_width=True):\n                    with st.spinner(\"Расчёт оптимального распределения...\"):\n                        optimization_settings = {\n                            'max_shift_days': max_shift_days,\n                            'target_load': target_load,\n                            'mode': opt_mode\n                        }\n                        st.session_state.optimization_results = optimize_with_task_shifting(\n                            st.session_state.parser, \n                            optimization_settings,\n                            st.session_state.date_range_start,\n                            st.session_state.date_range_end,\n                            selected_resources\n                        )\n                        st.session_state.timeline_data = st.session_state.parser.get_timeline_workload(\n                            st.session_state.date_range_start,\n                            st.session_state.date_range_end\n                        )\n                        st.success(\"✓ Оптимизация завершена!\")\n                        st.rerun()\n            \n            # Показать результаты оптимизации\n            if st.session_state.optimization_results:\n                st.markdown(\"### 📈 Предложения по смещению задач\")\n                \n                opt_results = st.session_state.optimization_results\n                if opt_results:\n                    for i, suggestion in enumerate(opt_results[:10], 1):\n                        priority_color = {\n                            'Высокий': '#FF4B4B',\n                            'Средний': '#FFB900',\n                            'Низкий': '#107C10'\n                        }.get(suggestion.get('priority', 'Низкий'), '#107C10')\n                        \n                        improvement_info = f\"<b>Улучшение:</b> {suggestion['improvement']}<br/>\" if 'improvement' in suggestion else \"\"\n                        st.markdown(f\"\"\"\n                        <div style='background-color: white; padding: 15px; border-radius: 8px; \n                                    margin: 10px 0; border-left: 4px solid {priority_color}'>\n                            <b>{i}. Сдвинуть задачу \"{suggestion['task_name']}\"</b> \n                            <span style='background-color: {priority_color}; color: white; \n                                         padding: 2px 8px; border-radius: 3px; font-size: 12px; margin-left: 10px'>\n                                {suggestion['priority']}\n                            </span><br/>\n                            <b>Ресурс:</b> {suggestion['resource']}<br/>\n                            <b>Объём работы:</b> {suggestion['task_hours']:.1f} часов<br/>\n                            <b>Текущие даты:</b> {suggestion['original_start']} → {suggestion['original_end']}<br/>\n                            <b>Предлагаемые даты:</b> {suggestion['suggested_start']} → {suggestion['suggested_end']} \n                            (сдвиг на {suggestion['shift_days']} дн.)<br/>\n                            {improvement_info}\n                            <b>Причина:</b> {suggestion['reason']}\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n                else:\n                    st.success(\"✓ Распределение оптимально, смещения не требуются!\")\n            \n            # Временная загрузка ресурсов\n            if st.session_state.timeline_data:\n                st.markdown(\"### 📅 Временная загрузка ресурсов по неделям\")\n                \n                # Фильтрация timeline_data по выбранным ресурсам\n                if selected_resources:\n                    timeline_data = {k: v for k, v in st.session_state.timeline_data.items() if k in selected_resources}\n                else:\n                    timeline_data = st.session_state.timeline_data\n                \n                # Выбор ресурса для детальной визуализации\n                selected_resource_timeline = st.selectbox(\n                    \"Выберите ресурс для детального анализа\",\n                    options=list(timeline_data.keys()),\n                    key=\"timeline_resource_select\"\n                )\n                \n                if selected_resource_timeline and selected_resource_timeline in timeline_data:\n                    resource_timeline = timeline_data[selected_resource_timeline]\n                    \n                    # Получить MD3 цвета для графиков\n                    chart_colors = get_md3_chart_colors()\n                    color_overloaded = chart_colors['overloaded']\n                    color_optimal = chart_colors['optimal']\n                    color_underutilized = chart_colors['underutilized']\n                    color_primary = chart_colors['optimal']\n                    \n                    # График временной загрузки\n                    fig_timeline = go.Figure()\n                    \n                    weeks = [w['week'] for w in resource_timeline]\n                    percentages = [w['percentage'] for w in resource_timeline]\n                    hours = [w['hours'] for w in resource_timeline]\n                    \n                    # Подготовить данные в зависимости от режима\n                    if st.session_state.display_mode == 'hours':\n                        y_values = hours\n                        text_values = [f\"{h:.1f} ч.\" for h in hours]\n                        hover_template = '<b>%{x}</b><br>Загрузка: %{y:.1f} ч.<br><extra></extra>'\n                        yaxis_title = \"Загрузка (часы)\"\n                        \n                        # Пороговые линии в часах (на основе средней недельной ёмкости)\n                        avg_week_capacity = sum(hours) / len(hours) if hours else 40\n                        threshold_100 = avg_week_capacity\n                        threshold_target = avg_week_capacity * (target_load / 100)\n                        line1_text = f\"{threshold_100:.1f} ч. (100%)\"\n                        line2_text = f\"{threshold_target:.1f} ч. ({target_load}%)\"\n                    else:\n                        y_values = percentages\n                        text_values = [f\"{p:.1f}%\" for p in percentages]\n                        hover_template = '<b>%{x}</b><br>Загрузка: %{y:.1f}%<br>Часов: %{customdata:.1f} ч.<br><extra></extra>'\n                        yaxis_title = \"Загрузка (%)\"\n                        threshold_100 = 100\n                        threshold_target = target_load\n                        line1_text = \"100%\"\n                        line2_text = f\"Цель {target_load}%\"\n                    \n                    # Цветовая кодировка по неделям\n                    colors_timeline = []\n                    for pct in percentages:\n                        if pct > 100:\n                            colors_timeline.append(color_overloaded)\n                        elif pct >= 70:\n                            colors_timeline.append(color_optimal)\n                        else:\n                            colors_timeline.append(color_underutilized)\n                    \n                    fig_timeline.add_trace(go.Bar(\n                        x=weeks,\n                        y=y_values,\n                        marker_color=colors_timeline,\n                        text=text_values,\n                        textposition='outside',\n                        customdata=hours,\n                        hovertemplate=hover_template,\n                        name='Загрузка'\n                    ))\n                    \n                    fig_timeline.add_hline(y=threshold_100, line_dash=\"dash\", line_color=color_overloaded, \n                                          annotation_text=line1_text, annotation_position=\"right\")\n                    fig_timeline.add_hline(y=threshold_target, line_dash=\"dot\", line_color=color_primary, \n                                          annotation_text=line2_text, annotation_position=\"right\")\n                    \n                    fig_timeline.update_layout(\n                        title=f\"Недельная загрузка: {selected_resource_timeline}\",\n                        xaxis_title=\"Неделя\",\n                        yaxis_title=yaxis_title,\n                        showlegend=False,\n                        height=400,\n                        plot_bgcolor='white',\n                        paper_bgcolor='white',\n                        font=dict(family=\"Segoe UI, Inter, sans-serif\", size=12, color=\"#323130\")\n                    )\n                    \n                    st.plotly_chart(fig_timeline, use_container_width=True)\n            \n            # Интерактивная замена специалистов\n            if filtered_analysis['overloaded']:\n                st.markdown(\"---\")\n                st.markdown(\"### 🔄 Интерактивная замена специалистов\")\n                st.info(\"Выберите замену для перегруженных специалистов и пересчитайте оптимизацию\")\n                \n                for overloaded_resource in filtered_analysis['overloaded'][:3]:  # Топ-3 перегруженных\n                    resource_name = overloaded_resource['resource_name']\n                    overload_pct = overloaded_resource['workload_percentage']\n                    \n                    with st.expander(f\"⚠️ {resource_name} ({overload_pct:.1f}% перегрузка)\"):\n                        st.markdown(f\"**Текущая загрузка:** {overload_pct:.1f}%\")\n                        st.markdown(f\"**Избыток:** {overload_pct - 100:.1f}%\")\n                        \n                        # Варианты замены (недоиспользуемые ресурсы)\n                        replacement_options = [r['resource_name'] for r in filtered_analysis['underutilized']]\n                        replacement_options.insert(0, \"-- Не менять --\")\n                        \n                        selected_replacement = st.selectbox(\n                            \"Заменить на:\",\n                            options=replacement_options,\n                            key=f\"replacement_{resource_name}\"\n                        )\n                        \n                        if selected_replacement != \"-- Не менять --\":\n                            if st.button(f\"✓ Применить замену {resource_name} → {selected_replacement}\", \n                                       key=f\"apply_{resource_name}\"):\n                                st.session_state.resource_replacements[resource_name] = selected_replacement\n                                st.success(f\"✓ Замена сохранена: {resource_name} → {selected_replacement}\")\n                                st.info(\"💡 Запустите оптимизацию заново для пересчёта с учётом замены\")\n                \n                # Показать активные замены\n                if st.session_state.resource_replacements:\n                    st.markdown(\"**Активные замены:**\")\n                    for old_res, new_res in st.session_state.resource_replacements.items():\n                        st.markdown(f\"- {old_res} → {new_res}\")\n                    \n                    if st.button(\"🔄 Пересчитать с учётом замен\", use_container_width=True):\n                        st.info(\"💡 Функция в разработке: автоматический пересчёт с учётом замен специалистов\")\n            \n            # Опции экспорта\n            st.markdown(\"---\")\n            st.markdown(\"### 📥 Экспорт анализа\")\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                # Рассчитать параметры периода для экспорта\n                export_date_start = st.session_state.date_range_start\n                export_date_end = st.session_state.date_range_end\n                export_business_days = None\n                export_capacity = None\n                \n                if export_date_start and export_date_end:\n                    export_business_days = calculate_business_days(export_date_start, export_date_end)\n                    export_capacity = calculate_work_capacity(export_business_days)\n                \n                csv_data = export_to_csv(\n                    df, \n                    analysis, \n                    parser=st.session_state.parser,\n                    timeline_data=st.session_state.timeline_data,\n                    optimization_results=st.session_state.optimization_results,\n                    date_start=export_date_start,\n                    date_end=export_date_end,\n                    business_days=export_business_days,\n                    capacity=export_capacity\n                )\n                st.download_button(\n                    label=\"📄 Скачать CSV\",\n                    data=csv_data,\n                    file_name=f\"resource_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\",\n                    use_container_width=True\n                )\n            \n            with col2:\n                pdf_data = export_to_pdf(\n                    df, \n                    analysis, \n                    recommendations,\n                    parser=st.session_state.parser,\n                    timeline_data=st.session_state.timeline_data,\n                    optimization_results=st.session_state.optimization_results,\n                    date_start=export_date_start,\n                    date_end=export_date_end,\n                    business_days=export_business_days,\n                    capacity=export_capacity\n                )\n                st.download_button(\n                    label=\"📑 Скачать PDF\",\n                    data=pdf_data,\n                    file_name=f\"resource_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\",\n                    mime=\"application/pdf\",\n                    use_container_width=True\n                )\n            \n            # Визуализация\n            st.markdown(\"### 📊 Распределение рабочей нагрузки\")\n            \n            # Получить MD3 цвета для графиков\n            chart_colors = get_md3_chart_colors()\n            color_overloaded = chart_colors['overloaded']\n            color_optimal = chart_colors['optimal']\n            color_underutilized = chart_colors['underutilized']\n            \n            fig = go.Figure()\n            \n            # Подготовить данные в зависимости от режима отображения\n            if st.session_state.display_mode == 'hours':\n                # Режим часов\n                y_values = [(item['max_capacity'] * item['workload_percentage'] / 100) for item in display_data]\n                text_values = [f\"{y:.1f} ч.\" for y in y_values]\n                hover_template = '<b>%{x}</b><br>Загрузка: %{y:.1f} ч.<br><extra></extra>'\n                yaxis_title = \"Загрузка (часы)\"\n                \n                # Пороговые линии в часах (средняя ёмкость)\n                avg_capacity = sum([item['max_capacity'] for item in display_data]) / len(display_data) if display_data else 0\n                threshold_100 = avg_capacity\n                threshold_70 = avg_capacity * 0.7\n                line1_text = f\"{threshold_100:.1f} ч. (100%)\"\n                line2_text = f\"{threshold_70:.1f} ч. (70%)\"\n            else:\n                # Режим процентов\n                y_values = [item['workload_percentage'] for item in display_data]\n                text_values = [f\"{y:.1f}%\" for y in y_values]\n                hover_template = '<b>%{x}</b><br>Нагрузка: %{y:.1f}%<br><extra></extra>'\n                yaxis_title = \"Процент нагрузки (%)\"\n                threshold_100 = 100\n                threshold_70 = 70\n                line1_text = \"100% ёмкость\"\n                line2_text = \"70% порог\"\n            \n            # Цветовая кодировка\n            colors_map = []\n            for item in display_data:\n                percentage = item['workload_percentage']\n                if percentage > 100:\n                    colors_map.append(color_overloaded)\n                elif percentage >= 70:\n                    colors_map.append(color_optimal)\n                else:\n                    colors_map.append(color_underutilized)\n            \n            fig.add_trace(go.Bar(\n                x=[item['resource_name'] for item in display_data],\n                y=y_values,\n                marker_color=colors_map,\n                text=text_values,\n                textposition='outside',\n                hovertemplate=hover_template\n            ))\n            \n            # Добавление пороговых линий\n            fig.add_hline(y=threshold_100, line_dash=\"dash\", line_color=color_overloaded, \n                         annotation_text=line1_text, annotation_position=\"right\")\n            fig.add_hline(y=threshold_70, line_dash=\"dash\", line_color=color_underutilized, \n                         annotation_text=line2_text, annotation_position=\"right\")\n            \n            fig.update_layout(\n                title=\"Сравнение рабочей нагрузки ресурсов\",\n                xaxis_title=\"Ресурс\",\n                yaxis_title=yaxis_title,\n                showlegend=False,\n                height=500,\n                plot_bgcolor='white',\n                paper_bgcolor='white',\n                font=dict(family=\"Segoe UI, Inter, sans-serif\", size=12, color=\"#323130\")\n            )\n            \n            fig.update_xaxes(showgrid=False)\n            fig.update_yaxes(showgrid=True, gridcolor='#E5E5E5')\n            \n            st.plotly_chart(fig, use_container_width=True)\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":119239},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"fpdf>=1.7.2\",\n    \"lxml>=6.0.2\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.3\",\n    \"plotly>=6.3.1\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"reportlab>=4.4.4\",\n    \"streamlit>=1.51.0\",\n]\n","size_bytes":332},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96},"BUILD_INSTRUCTIONS.md":{"content":"# Инструкция по созданию .exe файла для Windows 10\n\n## Требования\n\n### Обязательно:\n1. **Windows 10** (64-bit рекомендуется)\n2. **Python 3.10 или выше** - скачайте с [python.org](https://www.python.org/downloads/)\n   - ⚠️ При установке обязательно отметьте **\"Add Python to PATH\"**\n3. **Интернет-подключение** (для установки зависимостей)\n4. **Минимум 2 ГБ свободного места** на диске\n\n### Рекомендуется:\n- **4 ГБ RAM** или больше\n- **Антивирус временно отключен** (PyInstaller иногда блокируется антивирусами)\n\n---\n\n## Быстрый старт (автоматическая сборка)\n\n### Шаг 1: Скачайте проект\nСкачайте все файлы проекта в одну папку на вашем компьютере:\n```\nC:\\MSProjectAnalyzer\\\n  ├── app.py\n  ├── run_app.py          (launcher для .exe)\n  ├── md3_components.py\n  ├── app.spec\n  ├── build_exe.bat\n  ├── requirements_exe.txt\n  └── .streamlit\\\n      └── config.toml\n```\n\n### Шаг 2: Запустите сборку\n1. Откройте папку проекта в Проводнике\n2. **Дважды кликните** по файлу `build_exe.bat`\n3. Дождитесь завершения (5-15 минут)\n\n### Шаг 3: Готово!\nПосле успешной сборки в папке появится файл:\n```\nMSProjectAnalyzer.exe  (примерно 150-300 МБ)\n```\n\n---\n\n## Ручная сборка (если автоматическая не работает)\n\n### Шаг 1: Откройте командную строку\n1. Нажмите **Win + R**\n2. Введите `cmd` и нажмите Enter\n3. Перейдите в папку проекта:\n   ```cmd\n   cd C:\\MSProjectAnalyzer\n   ```\n\n### Шаг 2: Установите зависимости\n```cmd\npython -m pip install --upgrade pip\npython -m pip install -r requirements_exe.txt\n```\n\n### Шаг 3: Соберите .exe\n```cmd\npyinstaller app.spec --clean\n```\n\n### Шаг 4: Найдите результат\nГотовый файл будет в папке:\n```\ndist\\MSProjectAnalyzer.exe\n```\n\n---\n\n## Как использовать .exe файл\n\n### Первый запуск:\n1. **Дважды кликните** по `MSProjectAnalyzer.exe`\n2. Откроется окно консоли (черное окно) - **НЕ закрывайте его!**\n3. Через 5-10 секунд автоматически откроется браузер с приложением\n4. Адрес в браузере: `http://localhost:8501`\n\n### Загрузка файла проекта:\n1. В приложении нажмите **\"Browse files\"** или перетащите файл `.xml`\n2. Нажмите **\"🔄 Анализировать файл\"**\n3. Используйте все функции как обычно\n\n### Закрытие приложения:\n1. Закройте вкладку браузера\n2. Закройте окно консоли (черное окно)\n\n---\n\n## Решение проблем\n\n### ❌ Ошибка: \"Python не найден\"\n**Решение:**\n1. Переустановите Python с [python.org](https://www.python.org/downloads/)\n2. При установке отметьте **\"Add Python to PATH\"**\n3. Перезагрузите компьютер\n4. Проверьте: откройте `cmd` и введите `python --version`\n\n### ❌ Ошибка: \"Не удалось установить зависимости\"\n**Решение:**\n1. Убедитесь что интернет работает\n2. Попробуйте обновить pip:\n   ```cmd\n   python -m pip install --upgrade pip\n   ```\n3. Установите зависимости по одной:\n   ```cmd\n   python -m pip install streamlit\n   python -m pip install pandas\n   python -m pip install lxml\n   python -m pip install plotly\n   python -m pip install reportlab\n   python -m pip install pyinstaller\n   ```\n\n### ❌ Ошибка: \"PyInstaller failed\"\n**Решение:**\n1. **Временно отключите антивирус** (часто блокирует PyInstaller)\n2. Очистите кэш:\n   ```cmd\n   rd /s /q build\n   rd /s /q dist\n   rd /s /q __pycache__\n   ```\n3. Попробуйте снова: `pyinstaller app.spec --clean`\n\n### ❌ .exe запускается, но браузер не открывается\n**Решение:**\n1. Откройте браузер вручную\n2. Перейдите по адресу: `http://localhost:8501`\n3. Если не работает, проверьте в консоли номер порта (может быть 8502, 8503...)\n\n### ❌ Антивирус блокирует .exe файл\n**Решение:**\n1. Добавьте `MSProjectAnalyzer.exe` в исключения антивируса\n2. Это **не вирус** - это ложное срабатывание на упакованный Python код\n3. Вы можете проверить файл на [VirusTotal](https://www.virustotal.com/)\n\n### ❌ Ошибка \"Failed to execute script\"\n**Решение:**\n1. Убедитесь что рядом с .exe есть папка `_internal` (создается PyInstaller)\n2. Запустите .exe из командной строки чтобы увидеть ошибку:\n   ```cmd\n   MSProjectAnalyzer.exe\n   ```\n3. Пересоберите с флагом `--debug`:\n   ```cmd\n   pyinstaller app.spec --clean --debug all\n   ```\n\n### ❌ Ошибка \"PackageNotFoundError: No package metadata was found for streamlit\"\n**Что это:**\n- Это происходит когда PyInstaller не включил метаданные библиотек (version info)\n- Streamlit проверяет версию при запуске, и если метаданных нет - падает с этой ошибкой\n\n**Решение:**\nФайл `app.spec` уже содержит исправление - строки `copy_metadata()` для всех библиотек:\n```python\n# Добавить метаданные пакетов (решает ошибку PackageNotFoundError)\ndatas += copy_metadata('streamlit')\ndatas += copy_metadata('pandas')\ndatas += copy_metadata('plotly')\n...\n```\n\nЕсли ошибка всё равно появляется:\n1. Убедитесь что используете последнюю версию `app.spec` из проекта\n2. Пересоберите .exe заново:\n   ```cmd\n   rd /s /q build dist\n   pyinstaller app.spec --clean\n   ```\n3. Проверьте что все библиотеки установлены:\n   ```cmd\n   python -m pip list\n   ```\n\n### ❌ Ошибка при установке pandas/pyarrow (cmake failed, subprocess-exited-with-error)\n**Что это:**\n- Windows пытается скомпилировать библиотеки из исходников, но не хватает компилятора\n\n**Решение:**\n1. **Сначала попробуйте:** Установить готовые wheel-файлы:\n   ```cmd\n   python -m pip install --upgrade pip wheel setuptools\n   python -m pip install --only-binary :all: pyarrow pandas\n   python -m pip install streamlit lxml plotly reportlab openpyxl python-dateutil fpdf pyinstaller\n   ```\n\n2. **Если не помогло:** Проверьте что у вас **64-битный Python**:\n   ```cmd\n   python -c \"import platform; print(platform.architecture())\"\n   ```\n   Должно показать: `('64bit', 'WindowsPE')`  \n   Если показывает `32bit` - переустановите Python 64-bit с [python.org](https://www.python.org/downloads/)\n\n3. **Последний вариант:** Установите [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)\n\n---\n\n## Распространение .exe файла\n\n### Что нужно передать пользователям:\n1. **Только файл `MSProjectAnalyzer.exe`** - это всё!\n2. Никаких дополнительных файлов или установок Python не требуется\n\n### Требования к компьютеру пользователя:\n- Windows 10 или выше (64-bit)\n- 2 ГБ RAM минимум\n- Установленный браузер (Chrome, Firefox, Edge)\n- НЕ требуется установка Python\n- НЕ требуется установка дополнительных библиотек\n\n### Размер файла:\n- **150-300 МБ** - это нормально\n- Файл большой потому что содержит весь Python + все библиотеки\n- Это цена за автономность (не нужна установка)\n\n---\n\n## Альтернативные варианты\n\n### Вариант 1: Легкая сборка (требует Python у пользователя)\nЕсли .exe слишком большой, можно распространять исходники:\n1. Передайте папку с `.py` файлами\n2. Пользователь устанавливает зависимости: `pip install -r requirements_exe.txt`\n3. Запуск: `streamlit run app.py`\n\n### Вариант 2: Веб-версия (Replit Deploy)\nСамый простой вариант - опубликуйте на Replit:\n1. Нажмите кнопку **\"Deploy\"** в Replit\n2. Получите публичную ссылку\n3. Пользователи открывают в браузере, без установки\n\n---\n\n## Техническая информация\n\n### Что делает PyInstaller:\n- Упаковывает Python интерпретатор\n- Упаковывает все библиотеки (Streamlit, Pandas, Plotly...)\n- Упаковывает ваш код (run_app.py, app.py, md3_components.py)\n- Создает один .exe файл с автономным запуском\n- run_app.py - специальный launcher, который запускает Streamlit правильно\n\n### Структура app.spec:\n- `Analysis(['run_app.py'])` - точка входа через launcher\n- `hiddenimports` - скрытые зависимости Streamlit\n- `datas` - файлы данных (app.py, md3_components.py, config.toml)\n- `console=True` - показывать консоль для отладки\n- Можно добавить иконку: `icon='app.ico'`\n\n### Зачем нужен run_app.py:\n- Streamlit требует запуска через команду `streamlit run`\n- PyInstaller не может вызвать эту команду напрямую\n- run_app.py - это launcher, который эмулирует `streamlit run app.py`\n- Без него .exe будет падать с ошибкой \"must be run with streamlit run\"\n\n### Оптимизация размера:\nДля уменьшения размера .exe:\n1. Исключите ненужные библиотеки в `excludes`\n2. Используйте `upx=True` для сжатия (уже включено)\n3. Рассмотрите двухфайловую сборку вместо однофайловой\n\n---\n\n## Поддержка\n\nПри возникновении проблем:\n1. Проверьте все требования выше\n2. Внимательно прочитайте сообщения об ошибках\n3. Проверьте логи в окне консоли\n4. Попробуйте ручную сборку вместо автоматической\n\n**Удачной сборки!** 🚀\n","size_bytes":11917},"run_app.py":{"content":"\"\"\"\nLauncher script для запуска Streamlit приложения через PyInstaller\nЭтот файл решает проблему \"must be run with streamlit run\"\n\"\"\"\nimport sys\nimport os\nfrom streamlit.web import cli as stcli\n\nif __name__ == '__main__':\n    # Получить путь к app.py (в той же директории)\n    if getattr(sys, 'frozen', False):\n        # Если запущено через PyInstaller\n        application_path = sys._MEIPASS\n    else:\n        # Если запущено напрямую через Python\n        application_path = os.path.dirname(os.path.abspath(__file__))\n\n    app_path = os.path.join(application_path, 'app.py')\n\n    # Настроить аргументы для Streamlit CLI\n    sys.argv = [\n        \"streamlit\", \"run\", app_path, \"--server.headless=true\",\n        \"--browser.gatherUsageStats=false\"\n    ]\n\n    # Запустить Streamlit\n    sys.exit(stcli.main())\n","size_bytes":953},"md3_components.py":{"content":"\"\"\"\nMaterial Design 3 Theme Components\nСовременный дизайн на основе Material Design 3 с палитрой из #0078D4\n\"\"\"\n\nimport streamlit as st\n\n# MD3 цветовая палитра, сгенерированная из seed color #0078D4\nMD3_COLORS = {\n    # Light theme colors\n    'primary': '#005EB0',\n    'on_primary': '#FFFFFF',\n    'primary_container': '#D1E4FF',\n    'on_primary_container': '#001B3D',\n    \n    'secondary': '#545F71',\n    'on_secondary': '#FFFFFF',\n    'secondary_container': '#D8E3F8',\n    'on_secondary_container': '#111C2B',\n    \n    'tertiary': '#6D5677',\n    'on_tertiary': '#FFFFFF',\n    'tertiary_container': '#F5D9FF',\n    'on_tertiary_container': '#271431',\n    \n    'error': '#BA1A1A',\n    'on_error': '#FFFFFF',\n    'error_container': '#FFDAD6',\n    'on_error_container': '#410002',\n    \n    'background': '#FDFBFF',\n    'on_background': '#1A1C1E',\n    'surface': '#FDFBFF',\n    'on_surface': '#1A1C1E',\n    'surface_variant': '#DFE2EB',\n    'on_surface_variant': '#43474E',\n    \n    'outline': '#73777F',\n    'outline_variant': '#C3C6CF',\n}\n\ndef get_md3_css():\n    \"\"\"Возвращает CSS стили для темы Material Design 3\"\"\"\n    return f\"\"\"\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');\n        \n        /* MD3 Color Variables */\n        :root {{\n            --md-sys-color-primary: {MD3_COLORS['primary']};\n            --md-sys-color-on-primary: {MD3_COLORS['on_primary']};\n            --md-sys-color-primary-container: {MD3_COLORS['primary_container']};\n            --md-sys-color-on-primary-container: {MD3_COLORS['on_primary_container']};\n            \n            --md-sys-color-secondary: {MD3_COLORS['secondary']};\n            --md-sys-color-on-secondary: {MD3_COLORS['on_secondary']};\n            --md-sys-color-secondary-container: {MD3_COLORS['secondary_container']};\n            --md-sys-color-on-secondary-container: {MD3_COLORS['on_secondary_container']};\n            \n            --md-sys-color-tertiary: {MD3_COLORS['tertiary']};\n            --md-sys-color-on-tertiary: {MD3_COLORS['on_tertiary']};\n            --md-sys-color-tertiary-container: {MD3_COLORS['tertiary_container']};\n            --md-sys-color-on-tertiary-container: {MD3_COLORS['on_tertiary_container']};\n            \n            --md-sys-color-error: {MD3_COLORS['error']};\n            --md-sys-color-on-error: {MD3_COLORS['on_error']};\n            --md-sys-color-error-container: {MD3_COLORS['error_container']};\n            --md-sys-color-on-error-container: {MD3_COLORS['on_error_container']};\n            \n            --md-sys-color-background: {MD3_COLORS['background']};\n            --md-sys-color-on-background: {MD3_COLORS['on_background']};\n            --md-sys-color-surface: {MD3_COLORS['surface']};\n            --md-sys-color-on-surface: {MD3_COLORS['on_surface']};\n            --md-sys-color-surface-variant: {MD3_COLORS['surface_variant']};\n            --md-sys-color-on-surface-variant: {MD3_COLORS['on_surface_variant']};\n            \n            --md-sys-color-outline: {MD3_COLORS['outline']};\n            --md-sys-color-outline-variant: {MD3_COLORS['outline_variant']};\n        }}\n        \n        /* MD3 Typography Scale */\n        .md3-display-large {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 57px;\n            font-weight: 400;\n            line-height: 64px;\n            letter-spacing: -0.25px;\n        }}\n        \n        .md3-display-medium {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 45px;\n            font-weight: 400;\n            line-height: 52px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-display-small {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 36px;\n            font-weight: 400;\n            line-height: 44px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-headline-large {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 32px;\n            font-weight: 400;\n            line-height: 40px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-headline-medium {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 28px;\n            font-weight: 400;\n            line-height: 36px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-headline-small {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 24px;\n            font-weight: 400;\n            line-height: 32px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-title-large {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 22px;\n            font-weight: 400;\n            line-height: 28px;\n            letter-spacing: 0;\n        }}\n        \n        .md3-title-medium {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 16px;\n            font-weight: 500;\n            line-height: 24px;\n            letter-spacing: 0.15px;\n        }}\n        \n        .md3-title-small {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 500;\n            line-height: 20px;\n            letter-spacing: 0.1px;\n        }}\n        \n        .md3-body-large {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 16px;\n            font-weight: 400;\n            line-height: 24px;\n            letter-spacing: 0.5px;\n        }}\n        \n        .md3-body-medium {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 400;\n            line-height: 20px;\n            letter-spacing: 0.25px;\n        }}\n        \n        .md3-body-small {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 12px;\n            font-weight: 400;\n            line-height: 16px;\n            letter-spacing: 0.4px;\n        }}\n        \n        .md3-label-large {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 500;\n            line-height: 20px;\n            letter-spacing: 0.1px;\n        }}\n        \n        .md3-label-medium {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 12px;\n            font-weight: 500;\n            line-height: 16px;\n            letter-spacing: 0.5px;\n        }}\n        \n        .md3-label-small {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 11px;\n            font-weight: 500;\n            line-height: 16px;\n            letter-spacing: 0.5px;\n        }}\n        \n        /* MD3 App Styling */\n        .stApp {{\n            background-color: var(--md-sys-color-background);\n            font-family: 'Roboto', sans-serif;\n        }}\n        \n        /* MD3 Headers */\n        h1 {{\n            color: var(--md-sys-color-on-background);\n            font-family: 'Roboto', sans-serif;\n            font-size: 28px;\n            font-weight: 400;\n            line-height: 36px;\n        }}\n        \n        h2 {{\n            color: var(--md-sys-color-on-background);\n            font-family: 'Roboto', sans-serif;\n            font-size: 24px;\n            font-weight: 400;\n            line-height: 32px;\n        }}\n        \n        h3 {{\n            color: var(--md-sys-color-on-background);\n            font-family: 'Roboto', sans-serif;\n            font-size: 22px;\n            font-weight: 400;\n            line-height: 28px;\n        }}\n        \n        /* MD3 Elevated Card */\n        .md3-card {{\n            background-color: var(--md-sys-color-surface);\n            border-radius: 12px;\n            padding: 24px;\n            margin: 16px 0;\n            box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3), \n                        0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n            transition: box-shadow 0.3s ease;\n        }}\n        \n        .md3-card:hover {{\n            box-shadow: 0px 2px 6px 2px rgba(0, 0, 0, 0.15), \n                        0px 1px 2px 0px rgba(0, 0, 0, 0.30);\n        }}\n        \n        /* MD3 Buttons */\n        .md3-filled-button {{\n            background-color: var(--md-sys-color-primary);\n            color: var(--md-sys-color-on-primary);\n            border: none;\n            border-radius: 20px;\n            padding: 10px 24px;\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 500;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3), \n                        0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n        }}\n        \n        .md3-filled-button:hover {{\n            box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15), \n                        0px 1px 2px 0px rgba(0, 0, 0, 0.30);\n            background-color: #004a8f;\n        }}\n        \n        .md3-outlined-button {{\n            background-color: transparent;\n            color: var(--md-sys-color-primary);\n            border: 1px solid var(--md-sys-color-outline);\n            border-radius: 20px;\n            padding: 10px 24px;\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 500;\n            cursor: pointer;\n            transition: all 0.2s ease;\n        }}\n        \n        .md3-outlined-button:hover {{\n            background-color: rgba(0, 94, 176, 0.08);\n        }}\n        \n        .md3-text-button {{\n            background-color: transparent;\n            color: var(--md-sys-color-primary);\n            border: none;\n            border-radius: 20px;\n            padding: 10px 12px;\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            font-weight: 500;\n            cursor: pointer;\n            transition: all 0.2s ease;\n        }}\n        \n        .md3-text-button:hover {{\n            background-color: rgba(0, 94, 176, 0.08);\n        }}\n        \n        /* MD3 Dataframe Styling */\n        .dataframe {{\n            font-family: 'Roboto', sans-serif;\n            font-size: 14px;\n            border-radius: 12px;\n            overflow: hidden;\n        }}\n        \n        .dataframe thead tr th {{\n            background-color: var(--md-sys-color-surface-variant);\n            color: var(--md-sys-color-on-surface-variant);\n            font-weight: 500;\n            padding: 12px 16px;\n        }}\n        \n        .dataframe tbody tr:nth-child(even) {{\n            background-color: var(--md-sys-color-surface-variant);\n        }}\n        \n        .dataframe tbody tr:hover {{\n            background-color: rgba(0, 94, 176, 0.08);\n        }}\n        \n        .dataframe tbody tr td {{\n            padding: 12px 16px;\n        }}\n    </style>\n    \"\"\"\n\n\ndef md3_metric_card(icon, value, label, description=\"\"):\n    \"\"\"\n    Создает MD3 метрику в стиле Elevated Card\n    \n    Args:\n        icon: Эмодзи иконка\n        value: Значение метрики\n        label: Название метрики\n        description: Дополнительное описание (опционально)\n    \"\"\"\n    desc_html = f'<div class=\"md3-body-small\" style=\"color: var(--md-sys-color-on-surface-variant); margin-top: 4px;\">{description}</div>' if description else ''\n    \n    return f\"\"\"\n    <div class=\"md3-card\" style=\"text-align: center;\">\n        <div style=\"font-size: 32px; margin-bottom: 8px;\">{icon}</div>\n        <div class=\"md3-display-small\" style=\"color: var(--md-sys-color-on-surface); margin-bottom: 4px;\">{value}</div>\n        <div class=\"md3-label-medium\" style=\"color: var(--md-sys-color-on-surface-variant);\">{label}</div>\n        {desc_html}\n    </div>\n    \"\"\"\n\n\ndef md3_info_panel(period_text, business_days, capacity_hours):\n    \"\"\"\n    Создает панель управления периодом в MD3 стиле\n    \n    Args:\n        period_text: Текст периода анализа\n        business_days: Количество рабочих дней\n        capacity_hours: Рабочая ёмкость в часах\n    \"\"\"\n    return f\"\"\"\n    <div style=\"margin: 24px 0;\">\n        <div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;\">\n            {md3_metric_card(\"📅\", period_text, \"Период анализа\")}\n            {md3_metric_card(\"📊\", f\"{business_days} дн.\", \"Рабочие дни\", \"Пн-Пт\")}\n            {md3_metric_card(\"⏱️\", f\"{capacity_hours} ч\", \"Ёмкость на чел.\", f\"{business_days} × 8 часов\")}\n        </div>\n    </div>\n    \"\"\"\n\n\ndef md3_chip(text, closeable=False, chip_id=\"\"):\n    \"\"\"\n    Создает MD3 Chip компонент\n    \n    Args:\n        text: Текст чипа\n        closeable: Может ли чип быть удален\n        chip_id: ID чипа для идентификации при удалении\n    \"\"\"\n    close_btn = f'<button class=\"md3-chip-close\" onclick=\"removeChip(\\'{chip_id}\\')\">×</button>' if closeable else ''\n    \n    return f\"\"\"\n    <div class=\"md3-chip\" id=\"{chip_id}\">\n        <span class=\"md3-label-large\">{text}</span>\n        {close_btn}\n    </div>\n    \"\"\"\n\n\ndef get_md3_table_style():\n    \"\"\"Возвращает CSS для стилизации таблиц в MD3\"\"\"\n    return \"\"\"\n    <style>\n        /* MD3 Table Container */\n        .stDataFrame {{\n            border-radius: 12px;\n            overflow: hidden;\n        }}\n        \n        /* Status colors - MD3 style */\n        .status-overloaded {{\n            background-color: var(--md-sys-color-error-container);\n            color: var(--md-sys-color-on-error-container);\n            padding: 6px 12px;\n            border-radius: 8px;\n            font-weight: 500;\n            font-size: 12px;\n            display: inline-block;\n        }}\n        \n        .status-optimal {{\n            background-color: var(--md-sys-color-primary-container);\n            color: var(--md-sys-color-on-primary-container);\n            padding: 6px 12px;\n            border-radius: 8px;\n            font-weight: 500;\n            font-size: 12px;\n            display: inline-block;\n        }}\n        \n        .status-underutilized {{\n            background-color: var(--md-sys-color-tertiary-container);\n            color: var(--md-sys-color-on-tertiary-container);\n            padding: 6px 12px;\n            border-radius: 8px;\n            font-weight: 500;\n            font-size: 12px;\n            display: inline-block;\n        }}\n    </style>\n    \"\"\"\n\n\ndef get_md3_chart_colors():\n    \"\"\"Возвращает MD3 цвета для графиков Plotly\"\"\"\n    return {\n        'overloaded': MD3_COLORS['error'],\n        'optimal': MD3_COLORS['primary'],\n        'underutilized': MD3_COLORS['tertiary'],\n        'background': MD3_COLORS['surface'],\n        'text': MD3_COLORS['on_surface'],\n    }\n","size_bytes":14779}},"version":2}